#+title: Custom Vanilla Config
#+author: Sergio Pastor Pérez
#+startup: showeverything

* Package manager

Initialize the package manager:
#+begin_src emacs-lisp
;; Stright.el support
(setq straight-use-package-by-default t)
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 6))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
(straight-use-package 'use-package)
#+end_src

* Presonal information

#+begin_src emacs-lisp
(setq user-full-name "Sergio Pastor Pérez"
      user-mail-address "sergio.pastorperez@gmail.com")
#+end_src

* UI

Config:
#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(show-paren-mode 1)
(blink-cursor-mode 0)
(scroll-bar-mode -1)
(global-visual-line-mode 1) ;; Line truncation (to disable toggle this and toggle-truncate-lines)
(line-number-mode 1) ;; Display line number on mode-line
(column-number-mode 1) ;; Display column number on mode-line

;; Window divider settings
(setq window-divider-default-bottom-width 1
      window-divider-default-right-width 1
      window-divider-default-places t)
(window-divider-mode 1)

(defalias 'yes-or-no-p 'y-or-n-p)

(setq x-stretch-cursor t
      initial-scratch-message nil
      inhibit-default-init t
      inhibit-startup-screen t
      inhibit-startup-echo-area-message t)

(add-hook 'prog-mode-hook #'display-line-numbers-mode)
#+end_src

** Fix defaults

In emacs for history reasons C-i is the same key as TAB. This is a problem inherited from terminal emulators. Using GUI we can do better:
#+begin_src emacs-lisp
;; Fix TAB and C-i (only in GUI)
(when window-system
  (define-key input-decode-map [(control ?i)] [control-i])
  (define-key input-decode-map [(control ?I)] [(shift control-i)]))
#+end_src

Escape with ESC:
#+begin_src emacs-lisp
;; Make ESC close prompts
(global-set-key (kbd "<escape>") #'keyboard-escape-quit)
#+end_src

** Window management

#+begin_src emacs-lisp :tangle no
;; Create prefix
(define-prefix-command '+window-map)
(define-key +window-map (kbd "w") #'evil-window-next)
(define-key +window-map (kbd "W") #'evil-window-prev)
(define-key +window-map (kbd "C-W") #'evil-window-prev)
(define-key +window-map (kbd "C-w") #'evil-window-next)
(define-key +window-map (kbd "r") #'evil-window-rotate-downwards)
(define-key +window-map (kbd "R") #'evil-window-rotate-upwards)
(define-key +window-map (kbd "C-r") #'evil-window-rotate-downwards)
(define-key +window-map (kbd "C-R") #'evil-window-rotate-upwards)
(define-key +window-map (kbd "=") #'balance-windows)
(define-key +window-map (kbd "a") #'ace-window)

;; Unbind evil-keybinds and bind +window-map
(with-eval-after-load 'evil-maps
  (dolist (map '(evil-motion-state-map
                 evil-insert-state-map
                 evil-emacs-state-map))
    (define-key (eval map) (kbd "C-w") +window-map)))
#+end_src

*** Winner

Winner Mode is a global minor mode that allows you to “undo” and “redo” changes in WindowConfiguration.
#+begin_src emacs-lisp
(add-hook 'after-init-hook 'winner-mode)
#+end_src

*** Ibuffer

#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-b") #'ibuffer-other-window)
#+end_src

**** Icons

#+begin_src emacs-lisp
(use-package all-the-icons-ibuffer
  :hook (ibuffer-mode . all-the-icons-ibuffer-mode))
#+end_src

**** VC

Show files separated on version controlled projects.
#+begin_src emacs-lisp
(use-package ibuffer-vc
  :hook
  (ibuffer-mode . (lambda ()
                    (ibuffer-vc-set-filter-groups-by-vc-root)
                    (unless (eq ibuffer-sorting-mode 'alphabetic)
                      (ibuffer-do-sort-by-alphabetic)))))

(setq ibuffer-formats
      '((mark modified read-only vc-status-mini " "
              (name 18 18 :left :elide)
              " "
              (size 9 -1 :right)
              " "
              (mode 16 16 :left :elide)
              " "
              (vc-status 16 16 :left)
              " "
              vc-relative-file)))
#+end_src

*** TODO Popper

#+begin_src emacs-lisp
(use-package popper
  :bind (("C-x t l"   . popper-toggle-latest)
         ("C-x t n"   . popper-cycle)
         ("C-x t t" . popper-toggle-type))
  :init
  (setq popper-reference-buffers '("\\*Messages\\*"
                                   "Output\\*$"
                                   "\\*Async Shell Command\\*"
                                   help-mode
                                   helpful-mode
                                   ibuffer-mode
                                   eshell-mode
                                   compilation-mode
                                   comint-mode) ;; For compilation in commint mode (C-u)
        popper-display-function nil
        popper-mode-line (propertize " POP " 'face 'mode-line-emphasis)
        popper-echo-dispatch-keys '("C-0" "C-1" "C-2" "C-3" "C-4"
                                    "C-5" "C-6" "C-7" "C-8" "C-9"))
  (popper-mode +1)
  (popper-echo-mode +1)) ; For echo area hints
#+end_src

*** TODO Shackles

This seems to be the only rule that works:
#+begin_src emacs-lisp
(use-package shackle)
(setq shackle-rules '((compilation-mode :noselect t))
        shackle-default-rule '(:select t))

(shackle-mode)
#+end_src

** Highlighting
*** Line

Only highlight prog & text buffers
#+begin_src emacs-lisp
(use-package hl-line
  :hook
  (prog-mode . hl-line-mode)
  (text-mode . hl-line-mode))
#+end_src

*** Useless whitespaces

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook #'(lambda ()
                              (setq-local show-trailing-whitespace t)))
#+end_src

*** Comment keywords

#+begin_src emacs-lisp
(use-package hl-todo
  :hook (prog-mode . hl-todo-mode)
  :config
  (setq hl-todo-highlight-punctuation ":"
        hl-todo-keyword-faces
        `(("TODO"       warning bold)
          ("FIXME"      error bold)
          ("HACK"       font-lock-constant-face bold)
          ("REVIEW"     font-lock-keyword-face bold)
          ("NOTE"       success bold)
          ("DEPRECATED" font-lock-doc-face bold))))
#+end_src

*** Numbers

Highlight numbers.
#+begin_src emacs-lisp
(use-package highlight-numbers
  :hook
  (prog-mode . highlight-numbers-mode))
#+end_src

*** Escape secuences

Highlight escape sequences.
#+begin_src emacs-lisp
(use-package highlight-escape-sequences
  :init
  (hes-mode))
#+end_src

*** Parentheses

Highlights delimiters such as parentheses, brackets or braces according to their depth. Each successive level is highlighted in a different color. This makes it easy to spot matching delimiters, orient yourself in the code, and tell which statements are at a given depth.
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook
  (prog-mode . rainbow-delimiters-mode))
#+end_src

Dynamically highlights the parentheses surrounding point based on nesting-level using configurable lists of colors, background colors, and other properties.
#+begin_src emacs-lisp
(use-package highlight-parentheses
  :custom-face
  (highlight-parentheses-highlight ((t (:weight bold))))
  :hook
  (org-mode . highlight-parentheses-mode)
  (prog-mode . highlight-parentheses-mode)
  (eshell-mode . highlight-parentheses-mode)
  (minibuffer-setup . highlight-parentheses-minibuffer-setup))
#+end_src

*** Quoted

Highlight Lisp quotes and quoted symbols.
#+begin_src emacs-lisp
(use-package highlight-quoted
  :straight (highlight-quoted :type git :host github :repo "Fanael/highlight-quoted")
  :hook
  (emacs-lisp-mode . highlight-quoted-mode))
#+end_src

*** Defined

highlight-defined is an Emacs minor mode that highlights defined Emacs Lisp symbols in source code.

#+begin_src emacs-lisp
(use-package highlight-defined
  :hook
  (help-mode . highlight-defined-mode)
  (helpful-mode . highlight-defined-mode)
  (emacs-lisp-mode . highlight-defined-mode))
#+end_src

*** VC fringe diff

#+begin_src emacs-lisp
(use-package diff-hl
  :hook
  (dired-mode . diff-hl-dired-mode)
  (magit-pre-refresh . diff-hl-magit-pre-refresh)
  (magit-post-refresh . diff-hl-magit-post-refresh)
  :custom
  (diff-hl-side 'right)
  :config
  (with-eval-after-load 'evil-collection
    (evil-define-key* 'normal diff-hl-inline-popup-transient-mode-map "q" 'diff-hl-inline-popup-hide)
    (evil-define-key* 'normal diff-hl-inline-popup-transient-mode-map "p" 'diff-hl-show-hunk-previous)
    (evil-define-key* 'normal diff-hl-inline-popup-transient-mode-map "n" 'diff-hl-show-hunk-next)
    (evil-define-key* 'normal diff-hl-inline-popup-transient-mode-map "r" 'diff-hl-show-hunk-revert-hunk)
    (evil-define-key* 'normal diff-hl-inline-popup-transient-mode-map "c" 'diff-hl-show-hunk-copy-original-text))
  :init
  (global-diff-hl-mode)
  (diff-hl-flydiff-mode)
  (diff-hl-show-hunk-mouse-mode))
#+end_src

*** Rainbow mode

Highlight hex digits
#+begin_src emacs-lisp
(use-package rainbow-mode)

;; Rainbow mode colors cannot be displayed properly over hl-line-mode. Disable when toggling rainbow-mode.
(add-hook 'rainbow-mode-hook (lambda ()
                               (if (bound-and-true-p rainbow-mode)
                                   (hl-line-mode -1)
                                 (hl-line-mode 1))))
#+end_src

*** Ansi color

*Built-in from emacs 28.1*
This file provides a function that takes a string or a region containing Select Graphic Rendition (SGR) control sequences (formerly known as ANSI escape sequences) and tries to translate these into faces.
#+begin_src emacs-lisp
(require 'ansi-color)
(add-hook 'compilation-filter-hook 'ansi-color-compilation-filter)
;; (add-hook 'eshell-preoutput-filter-functions 'ansi-color-filter-apply) ;; Not used with xterm-color.
#+end_src

*** Xterm color

xterm-color.el is an ANSI control sequence to text-property translator.

Translation takes place through state machine emulation which provides a far more accurate, comprehensive result than ansi-color.el that is built-into Emacs, without compromising on performance.
#+begin_src emacs-lisp
(use-package xterm-color
  :after eshell
  :hook
  ;; Set the color preservation before the banner is loaded so it keeps the necessary propperties to display correctly.
  ;; The xterm-color author suggests to set the variable after the ~eshell-before-prompt-hook~ but that happens after the banner is printed and therfore all it's propperties get stripped out. Maybe open an issue on xterm-color repo.
  (eshell-banner-load . (lambda ()
                          (setq xterm-color-preserve-properties t)))
  :config
  (add-to-list 'eshell-preoutput-filter-functions 'xterm-color-filter)
  (setq eshell-output-filter-functions (remove 'eshell-handle-ansi-color eshell-output-filter-functions))
  (setenv "TERM" "xterm-256color"))
#+end_src

**** TODO Fix ubuntu progress bar

+ This won't work with Xterm color since it removes ~eshell-handle-ansi-color~ which is the function that ends up calling ~ansi-color-apply-on-region~.

Code from [[https://github.com/abo-abo/oremacs/blob/afa4d0e3b1a60467ec163220e9823d1f014ab6a4/modes/ora-shell.el][ora-shell.el]].
#+begin_src emacs-lisp
(defun ora-shell-hook ())

(advice-add 'ansi-color-apply-on-region :before 'ora-ansi-color-apply-on-region)

(defun ora-ansi-color-apply-on-region (begin end)
  "Fix progress bars for e.g. apt(8).
Display progress in the mode line instead."
  (let ((end-marker (copy-marker end))
        mb)
    (save-excursion
      (goto-char (copy-marker begin))
      (while (re-search-forward "\0337" end-marker t)
        (setq mb (match-beginning 0))
        (when (re-search-forward "\0338" end-marker t)
          (let ((progress (buffer-substring-no-properties
                           (+ mb 2) (- (point) 2))))
            (delete-region mb (point))
            (ora-apt-progress-message progress)))))))

(defun ora-apt-progress-message (progress)
  ;; (setq mode-line-process
  ;;       (if (string-match "Progress: \\[ *\\([0-9]+\\)%\\]" progress)
  ;;           (list (concat ":%s " (match-string 1 progress) "%%%% "))
  ;;         '(":%s")))
  ;; (force-mode-line-update)
  (message
   (replace-regexp-in-string
    "%" "%%"
    (ansi-color-apply progress))))
#+end_src

** Minimap

#+begin_src emacs-lisp
(use-package minimap
  :config
  (setq minimap-window-location 'right
        minimap-minimum-width 10
        minimap-dedicated-window nil
        minimap-hide-cursor nil
        minimap-hide-scroll-bar t
        minimap-hide-fringes t))
#+end_src

** Hydra

#+begin_src emacs-lisp
(use-package hydra)
#+end_src

** Treemacs

#+begin_src emacs-lisp
(use-package treemacs
  :bind (("C-x t 1"   . treemacs-delete-other-windows)
         ("C-x t t"   . treemacs)
         ("C-x t d"   . treemacs-select-directory)
         ("C-x t B"   . treemacs-bookmark)
         ("C-x t C-t" . treemacs-find-file)
         ("C-x t M-t" . treemacs-find-tag)))

(use-package treemacs-evil
  :after (treemacs evil))

(use-package treemacs-projectile
  :after (treemacs projectile))

(use-package treemacs-all-the-icons
  :config
  (treemacs-load-theme "all-the-icons"))

(use-package treemacs-magit
  :after (treemacs magit))

;; Integration between lsp-mode and treemacs and implementation of treeview controls using treemacs as a tree renderer.
(use-package lsp-treemacs
  :after lsp-mode
  :init
  (lsp-treemacs-sync-mode))
#+end_src

** Eros

Evaluation Result OverlayS for Emacs Lisp.
#+begin_src emacs-lisp
(use-package eros
  :init
  (eros-mode))
#+end_src

* Theming
** Modeline

#+begin_src emacs-lisp
(use-package doom-modeline
  :custom
  (doom-modeline-buffer-file-name-style 'truncate-upto-project)
  :init (doom-modeline-mode 1))

(use-package hide-mode-line)
#+end_src

** Color schemes

#+begin_src emacs-lisp
(setq custom-safe-themes t)
(with-eval-after-load 'ef-themes
    (load-theme 'ef-light))
#+end_src

*** Ef

#+begin_src emacs-lisp
(use-package ef-themes)
#+end_src

*** Doom

#+begin_src emacs-lisp
(use-package doom-themes
  :config
  ;; Global settings (defaults)
  (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
        doom-themes-enable-italic t) ; if nil, italics is universally disabled

  ;; Enable flashing mode-line on errors
  (doom-themes-visual-bell-config)
  ;; Corrects (and improves) org-mode's native fontification.
  (doom-themes-org-config))
#+end_src

*** Kaolin

#+begin_src emacs-lisp
(use-package kaolin-themes
  :custom
  (kaolin-themes-italic-comments t))
#+end_src

*** Tron legacy

#+begin_src emacs-lisp
(use-package tron-legacy-theme
  :config
  (setq tron-legacy-theme-vivid-cursor t))
#+end_src

** Fonts

#+begin_src emacs-lisp
(setq default-frame-alist
   '((font . "JetBrainsMono Nerd Font-12")))
#+end_src

** Icons

#+begin_src emacs-lisp
(use-package all-the-icons
  :if (display-graphic-p)
  :config
  (when window-system
    (if (not (x-list-fonts "all-the-icons"))
        (all-the-icons-install-fonts))))
#+end_src

** Auto dark

Auto-Dark-Emacs is an auto changer between 2 themes, dark/light.
*This only works for GNOME for now.*
#+begin_src emacs-lisp
(use-package auto-dark
  :init
  (setq auto-dark-light-theme 'ef-light
        auto-dark-dark-theme 'ef-night)
  (if (string= (getenv "XDG_CURRENT_DESKTOP") "GNOME") ;; Try to enable only for GNOME
      (auto-dark-mode 1)))
#+end_src

* Editing functionality
** Tabs

Disable tabs for identation, use spaces.
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 4)

(setq c-basic-offset 4
      c-default-style '((java-mode . "java")
                        (awk-mode . "awk")
                        (other . "linux")))
#+end_src

*** TODO Smart-tabs

Needs to have =indent-tabs-mode= enabled.
#+begin_src emacs-lisp
(use-package smart-tabs-mode)
#+end_src

** Mouse buttons

#+begin_src emacs-lisp
(with-eval-after-load 'evil-maps
  (define-key evil-motion-state-map (kbd "<mouse-8>") 'evil-jump-backward)
  (define-key evil-motion-state-map (kbd "<mouse-9>") 'evil-jump-forward))
#+end_src

** Evil

#+begin_src emacs-lisp
(use-package evil
  :demand t
  :bind
  (:map evil-motion-state-map
        ;; Unbound confliction keys
        ("C-e" . nil)
        ("C-y" . nil)
        ("TAB" . nil) ;; Remove the default binding so org-cycle can take precedence
        ;; Scrolling bindings
        ("C-<up>" . evil-scroll-line-up)
        ("C-<down>" . evil-scroll-line-down)
        ;; Jumping
        ("g D" . xref-find-definitions-other-window))
  (:map evil-normal-state-map
        ("C-." . nil)) ;; Remove the default binding so embark-act can take precedence
  :config
  (evil-mode 1)
  (evil-set-undo-system 'undo-tree)
  (mapc (lambda (mode)
          (evil-set-initial-state mode 'emacs))
        '(eww-mode
          profiler-report-mode
          pdf-view-mode))
  (define-key evil-motion-state-map (kbd "C-o") 'evil-jump-backward)
  (define-key evil-motion-state-map [control-i] 'evil-jump-forward) ;; In emacs normal C-i is tab. The remap is needed
  :init
  (setq evil-ex-substitute-global t     ; I like my s/../.. to by global by default
        evil-move-cursor-back nil       ; Don't move the block cursor when toggling insert mode
        evil-kill-on-visual-paste nil
        evil-want-keybinding nil))

(use-package evil-collection
  :after evil
  :init
  (with-eval-after-load 'evil-collection ;; After
    (setq evil-collection-mode-list (remq 'org evil-collection-mode-list)) ;; Remove org form the list, it's bugged in visual mode. This needs to be in :init to not be overrided by the default values when loaded
    (evil-collection-init))) ;; Enable for magit
#+end_src

*** Surround

#+begin_src emacs-lisp
(use-package evil-surround
  :after evil
  :config
  (global-evil-surround-mode 1))
#+end_src

*** Snipe

#+begin_src emacs-lisp
(use-package evil-snipe
  :after evil
  :config
  (evil-snipe-override-mode 1))
#+end_src

*** Googles

#+begin_src emacs-lisp
(use-package evil-goggles
  :after evil
  :config
  (evil-goggles-mode)

  ;; optionally use diff-mode's faces; as a result, deleted text
  ;; will be highlighed with `diff-removed` face which is typically
  ;; some red color (as defined by the color theme)
  ;; other faces such as `diff-added` will be used for other actions
  (evil-goggles-use-diff-faces)
  (setq evil-goggles-duration 0.1))
#+end_src

*** Multiedit (the keybind is not working)

#+begin_src emacs-lisp
(use-package evil-multiedit
  :after evil
  :config
  (evil-multiedit-default-keybinds)
  (evil-define-key* nil evil-multiedit-mode-map (kbd "C-c n") #'iedit-show/hide-context-lines))
#+end_src

*** Easymotion

#+begin_src emacs-lisp
(use-package evil-easymotion
  :bind (:map evilem-map
              ("SPC" . evil-avy-goto-char-timer))
  :init
  (evilem-default-keybindings "gs"))
#+end_src

*** Nerd commenter

#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :bind (("C-x C-;" . evilnc-comment-or-uncomment-lines)))
#+end_src

** Expand region

#+begin_src emacs-lisp
(use-package expand-region
  :after evil)

(defhydra hydra-expand-region (global-map "C-+")
  "expand region"
  ("+" er/expand-region)
  ("-" er/contract-region))
#+end_src

** Avy

Avy is a GNU Emacs package for jumping to visible text using a char-based decision tree
#+begin_src emacs-lisp
(use-package avy)
#+end_src

** Iedit

#+begin_src emacs-lisp
(use-package iedit
  :init
  (set-face-attribute 'iedit-occurrence nil :inherit 'lazy-highlight)) ;; Set iedit face to one that won't collide with lsp-face-highlight-textual
#+end_src

* History

Enable recent files.
#+begin_src emacs-lisp
(recentf-mode 1)
#+end_src

** Backups
Backup files preserve file contents prior to the current session.
Put backed-up files on a dedicated directory (avoids cluttering the working directory tree).
#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . "~/.saves")))
#+end_src

** Autosave

Auto-saving preserves the text from earlier in the current editing session.
Put autosave files on a dedicated directory (avoids cluttering the working directory tree).
#+begin_src emacs-lisp
(setq auto-save-file-name-transforms
      `((".*" ,(concat user-emacs-directory "auto-save/") t)))
#+end_src

** Save place

This means when you visit a file, point goes to the last place
where it was when you previously visited the same file.
#+begin_src emacs-lisp
(save-place-mode 1)
#+end_src

** Savehist

Persist history over Emacs restarts. Vertico sorts by history position.
#+begin_src emacs-lisp
(use-package savehist
  :init
  (savehist-mode))
#+end_src

** Undo-tree

Undo system that allows tree visualization.
#+begin_src emacs-lisp
(use-package undo-tree
  :init
  (global-undo-tree-mode)
  :config
  (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo"))
        undo-tree-visualizer-diff t))
#+end_src

* Help
** Helpful

Improved help system.
#+begin_src emacs-lisp
(use-package helpful
  :custom
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ("C-h f" . helpful-function)
  ([remap describe-symbol] . helpful-symbol)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-command] . helpful-command)
  ([remap describe-key] . helpful-key))
#+end_src

** Which-key

Key legend popup.
#+begin_src emacs-lisp
(use-package which-key
  :diminish
  :custom
  (which-key-idle-secondary-delay 0.01)
  :config
  (which-key-mode t))
#+end_src

* Completion
** Vertico

#+begin_src emacs-lisp
(use-package vertico
  :straight (:files (:defaults "extensions/*")) ;; Load the extensions
  ;; Create this types of visual transformations:
  ;; + ~/some/path//opt -> /opt
  ;; + /some/other/path/~/.config -> ~/.config
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)
  :custom
  (vertico-cycle t)
  :bind
  (:map vertico-map
  ("<prior>" . vertico-scroll-down)
  ("<next>" . vertico-scroll-up)
  ("<escape>" . minibuffer-keyboard-quit)
  ("RET" . vertico-directory-enter)
  ("DEL" . vertico-directory-delete-char)
  ("M-DEL" . vertico-directory-delete-word))
  :config
  (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
  (if (string= (getenv "XDG_SESSION_DESKTOP") "budgie-desktop") ;; Temp fix until I find why on budgie the key seccuence when pressing <'> with the current corne keyboard config is different than on others desktop environments.
      (define-key override-global-map (kbd "C-<dead-acute>") #'vertico-repeat)
    (define-key override-global-map (kbd "C-'") #'vertico-repeat))
  :init
  (vertico-mode)
  (vertico-mouse-mode))
#+end_src

** Orderless

Allow fuzy search on the completion framework.
#+begin_src emacs-lisp
(use-package orderless
  :demand t
  :config
  (defvar +orderless-dispatch-alist
    '((?% . char-fold-to-regexp)
      (?! . orderless-without-literal)
      (?`. orderless-initialism)
      (?= . orderless-literal)
      (?~ . orderless-flex)))

  (defun +orderless--suffix-regexp ()
    (if (and (boundp 'consult--tofu-char) (boundp 'consult--tofu-range))
        (format "[%c-%c]*$"
                consult--tofu-char
                (+ consult--tofu-char consult--tofu-range -1))
      "$"))

  ;; Recognizes the following patterns:
  ;; * ~flex flex~
  ;; * =literal literal=
  ;; * %char-fold char-fold%
  ;; * `initialism initialism`
  ;; * !without-literal without-literal!
  ;; * .ext (file extension)
  ;; * regexp$ (regexp matching at end)
  (defun +orderless-dispatch (word _index _total)
    (cond
     ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
     ((string-suffix-p "$" word)
      `(orderless-regexp . ,(concat (substring word 0 -1) (+orderless--suffix-regexp))))
     ;; File extensions
     ((and (or minibuffer-completing-file-name
               (derived-mode-p 'eshell-mode))
           (string-match-p "\\`\\.." word))
      `(orderless-regexp . ,(concat "\\." (substring word 1) (+orderless--suffix-regexp))))
     ;; Ignore single !
     ((equal "!" word) `(orderless-literal . ""))
     ;; Prefix and suffix
     ((if-let (x (assq (aref word 0) +orderless-dispatch-alist))
          (cons (cdr x) (substring word 1))
        (when-let (x (assq (aref word (1- (length word))) +orderless-dispatch-alist))
          (cons (cdr x) (substring word 0 -1)))))))

  ;; Define orderless style with initialism by default
  (orderless-define-completion-style +orderless-with-initialism
    (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))

  ;; You may want to combine the `orderless` style with `substring` and/or `basic`.
  ;; There are many details to consider, but the following configurations all work well.
  ;; Personally I (@minad) use option 3 currently. Also note that you may want to configure
  ;; special styles for special completion categories, e.g., partial-completion for files.
  ;;
  ;; 1. (setq completion-styles '(orderless))
  ;; This configuration results in a very coherent completion experience,
  ;; since orderless is used always and exclusively. But it may not work
  ;; in all scenarios. Prefix expansion with TAB is not possible.
  ;;
  ;; 2. (setq completion-styles '(substring orderless))
  ;; By trying substring before orderless, TAB expansion is possible.
  ;; The downside is that you can observe the switch from substring to orderless
  ;; during completion, less coherent.
  ;;
  ;; 3. (setq completion-styles '(orderless basic))
  ;; Certain dynamic completion tables (completion-table-dynamic)
  ;; do not work properly with orderless. One can add basic as a fallback.
  ;; Basic will only be used when orderless fails, which happens only for
  ;; these special tables.
  ;;
  ;; 4. (setq completion-styles '(substring orderless basic))
  ;; Combine substring, orderless and basic.
  ;;
  (setq completion-styles '(orderless basic)
        completion-category-defaults nil
        ;;; Enable partial-completion for files.
        ;;; Either give orderless precedence or partial-completion.
        ;;; Note that completion-category-overrides is not really an override,
        ;;; but rather prepended to the default completion-styles.
        ;; completion-category-overrides '((file (styles orderless partial-completion))) ;; orderless is tried first
        completion-category-overrides '((file (styles partial-completion)) ;; partial-completion is tried first
                                        ;; enable initialism by default for symbols
                                        (command (styles +orderless-with-initialism))
                                        (variable (styles +orderless-with-initialism))
                                        (symbol (styles +orderless-with-initialism)))
        orderless-component-separator #'orderless-escapable-split-on-space ;; allow escaping space with backslash!
        orderless-style-dispatchers '(+orderless-dispatch)))
#+end_src

** Marginalia

Add contextual information on the completion menus.
#+begin_src emacs-lisp
(use-package marginalia
  :bind (("M-A" . marginalia-cycle)
         :map minibuffer-local-map
           ("M-A" . marginalia-cycle))
  :custom
    (marginalia-max-relative-age 0)
    (marginalia-align 'left)
  :init
    (marginalia-mode))
#+end_src

** Icons

Enable icons on the completion framework.
#+begin_src emacs-lisp
(use-package all-the-icons-completion
  :after (marginalia all-the-icons)
  :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
  :config (setq all-the-icons-scale-factor 1.0)
  :init (all-the-icons-completion-mode))
#+end_src

** Corfu

Autocompletion for inline text.
#+begin_src emacs-lisp
(use-package corfu
  :straight (:files (:defaults "extensions/*")) ;; Load the extensions
  ;; Optional customizations
  :custom
  (corfu-cycle t)                  ; Allows cycling through candidates
  (corfu-auto t)                   ; Enable auto completion
  (tab-always-indent 'complete)

  :bind (:map corfu-map
              ("C-SPC" . corfu-insert-separator)
              ("RET" . nil))
  :config
  (defun corfu-enable-always-in-minibuffer ()
    "Enable Corfu in the minibuffer if Vertico/Mct are not active."
    (unless (or (bound-and-true-p mct--active)
                (bound-and-true-p vertico--input))
      (setq-local corfu-auto t)
      (corfu-mode)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer)

  ;; Fix comint mode map taking precedence over corfu
  (evil-define-key* 'insert corfu-map (kbd "<up>") #'corfu-previous)
  (evil-define-key* 'insert corfu-map (kbd "<down>") #'corfu-next)
  :init
  (global-corfu-mode)
  (corfu-history-mode))
#+end_src

*** Documentation popup

#+begin_src emacs-lisp
(use-package corfu-doc
  :after corfu
  :bind (:map corfu-map
              ("M-e" . corfu-doc-scroll-down)
              ("M-d" . corfu-doc-scroll-up)
              ("M-c" . corfu-doc-toggle))
  :hook (corfu-mode-hook . corfu-doc-mode))
#+end_src

*** Icons

#+begin_src emacs-lisp
(use-package kind-icon
  :after corfu
  :custom
  (kind-icon-default-face 'corfu-default) ; to compute blended backgrounds correctly
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src

** Cape

#+begin_src emacs-lisp
(require 'dash)
(use-package cape
  ;; Bind dedicated completion commands
  ;; Alternative prefix keys: C-c p, M-p, M-+, ...
  :bind (("M-p p" . completion-at-point) ;; capf
         ("M-p t" . complete-tag)        ;; etags
         ("M-p d" . cape-dabbrev)        ;; or dabbrev-completion
         ("M-p h" . cape-history)
         ("M-p f" . cape-file)
         ("M-p k" . cape-keyword)
         ("M-p s" . cape-symbol)
         ("M-p a" . cape-abbrev)
         ("M-p i" . cape-ispell)
         ("M-p l" . cape-line)
         ("M-p w" . cape-dict)
         ("M-p \\" . cape-tex)
         ("M-p _" . cape-tex)
         ("M-p ^" . cape-tex)
         ("M-p &" . cape-sgml)
         ("M-p r" . cape-rfc1345))
  :hook
  (prog-mode . (lambda ()
                 (let ((backendList '(cape-file cape-keyword cape-dabbrev cape-symbol)))
                     (if (member 'elisp-completion-at-point completion-at-point-functions)
                     (setq-local completion-at-point-functions (-union '(cape-file) (-union completion-at-point-functions backendList))) ;; Add cape-file as the first candidate, later the normal emacs-lisp completion and finally the rest of caps
                   (setq-local completion-at-point-functions (-union backendList completion-at-point-functions)))))) ;; Try first keywords and dabbrev after (lsp completion will take precedence) on prog derived modes. File completion will still work if preceded by <.>
  (lsp-after-initialize . (lambda ()
                (setq-local completion-at-point-functions (-union '(cape-file) completion-at-point-functions)))) ;; Add file completion as first candidate since it won't usually conflict with any other completion backends.
  (text-mode . (lambda ()
                 (setq-local completion-at-point-functions (-union '(cape-file cape-dabbrev) completion-at-point-functions)))))
#+end_src

** Yasnippet

#+begin_src emacs-lisp
(use-package yasnippet
  :config
  (defun +yas/org-last-src-lang ()
    "Return the language of the last src-block, if it exists."
    (save-excursion
      (beginning-of-line)
      (when (re-search-backward "^[ \t]*#\\+begin_src" nil t)
        (org-element-property :language (org-element-context)))))
  :init (yas-global-mode 1))

(use-package yasnippet-snippets)
#+end_src

** Extras

#+begin_src emacs-lisp
(advice-add #'vertico--format-candidate :around
            (lambda (orig cand prefix suffix index _start)
              (setq cand (funcall orig cand prefix suffix index _start))
              (concat
               (if (= vertico--index index)
                   (propertize "» " 'face 'vertico-current)
                 "  ")
               cand)))

;; Add prompt indicator to `completing-read-multiple'.
;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
(defun crm-indicator (args)
  (cons (format "[CRM%s] %s"
                (replace-regexp-in-string
                 "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                 crm-separator)
                (car args))
        (cdr args)))
(advice-add #'completing-read-multiple :filter-args #'crm-indicator)
#+end_src

* Search
** Wgrep
wgrep allows you to edit a grep buffer and apply those changes to the file buffer like sed interactively. No need to learn sed script, just learn Emacs.
#+begin_src emacs-lisp
(use-package wgrep)
#+end_src

** Consult

Adds emacs wrappers on UNIX search commands.
#+begin_src emacs-lisp
(use-package consult
  ;; Replace bindings. Lazily loaded due by `use-package'.
  :bind (;; C-c bindings (mode-specific-map)
         ("C-c h" . consult-history)
         ("C-c m" . consult-mode-command)
         ("C-c k" . consult-kmacro)
         ;; C-x bindings (ctl-x-map)
         ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
         ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
         ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
         ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
         ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ("<help> a" . consult-apropos)            ;; orig. apropos-command
         ;; M-g bindings (goto-map)
         ("M-g e" . consult-compile-error)
         ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ;; M-s bindings (search-map)
         ("M-s d" . consult-find)
         ("M-s D" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
         ;; Minibuffer history
         :map minibuffer-local-map
         ("M-s" . consult-history)                 ;; orig. next-matching-history-element
         ("M-r" . consult-history))                ;; orig. previous-matching-history-element

  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI.
  :hook (completion-list-mode . consult-preview-at-point-mode)

  ;; The :init configuration is always executed (Not lazy)
  :init

  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)

  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config

  ;; Optionally configure preview. The default value
  ;; is 'any, such that any key triggers the preview.
  ;; (setq consult-preview-key 'any)
  ;; (setq consult-preview-key (kbd "M-."))
  ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
  ;; For some commands and buffer sources it is useful to configure the
  ;; :preview-key on a per-command basis using the `consult-customize' macro.
  (consult-customize
   consult-theme :preview-key '(:debounce 0.2 any)
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-file-register
   consult--source-recent-file consult--source-project-recent-file
   ;; :preview-key (kbd "M-.")
   :preview-key '(:debounce 0.4 any))

  ;; Optionally configure the narrowing key.
  ;; Both "<" and "C-+" work reasonably well.
  (setq consult-narrow-key "<") ;; (kbd "C-+")

  ;; Optionally make narrowing help available in the minibuffer.
  ;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

  ;; By default `consult-project-function' uses `project-root' from project.el.
  ;; Optionally configure a different project root function.
  ;; There are multiple reasonable alternatives to chose from.
  ;;;; 1. project.el (the default)
  ;; (setq consult-project-function #'consult--default-project--function)
  ;;;; 2. projectile.el (projectile-project-root)
  ;; (autoload 'projectile-project-root "projectile")
  ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
  ;;;; 3. vc.el (vc-root-dir)
  ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
  ;;;; 4. locate-dominating-file
  ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
)
#+end_src

*** Dir

Choose a directory and act on it.
#+begin_src emacs-lisp
(use-package consult-dir
  :bind (("C-x C-d" . consult-dir)
         :map vertico-map
         ("C-x C-d" . consult-dir)
         ("C-x C-j" . consult-dir-jump-file)))
#+end_src

** Dumb jump

A fantastic package that uses regex to find possible matches of the target at point
#+begin_src emacs-lisp
(use-package dumb-jump
  :config
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+end_src

* Version control
** Magit

Magit is a complete text-based user interface to Git.
#+begin_src emacs-lisp
(use-package magit)
#+end_src

** Gitignore

#+begin_src emacs-lisp
(use-package gitignore
  :straight (gitignore :type git :host github :repo "syohex/emacs-gitignore"))
#+end_src

* Automatic insertions
** Smartparentheses

Minor mode for Emacs that deals with parens pairs and tries to be smart about it.
#+begin_src emacs-lisp
(use-package smartparens
  :hook
  (eshell-mode . smartparens-mode) ;; Also enable for eshell
  :config
  (require 'smartparens-config)
  (setq sp-highlight-pair-overlay nil ;; Do not highlight space between parentheses when they are inserted
        sp-ignore-modes-list (delete 'minibuffer-mode sp-ignore-modes-list)) ;; Enable in the minibuffer
  (sp-local-pair 'minibuffer-mode "'" nil :actions nil) ;; Disable pairing single quotes on minibuffer
  (when window-system ;; This breaks on terminal mode
    (define-key smartparens-mode-map (kbd "M-i") #'sp-forward-slurp-sexp)
    (define-key smartparens-mode-map (kbd "M-I") #'sp-backward-slurp-sexp)
    (define-key smartparens-mode-map (kbd "M-o") #'sp-forward-barf-sexp)
    (define-key smartparens-mode-map (kbd "M-O") #'sp-backward-barf-sexp))
  :init
  (smartparens-global-mode))
#+end_src

* Embark

Embark makes it easy to choose a command to run based on what is near point, both during a minibuffer completion session (in a way familiar to Helm or Counsel users) and in normal buffers.
#+begin_src emacs-lisp
(use-package embark
  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'
  :init
  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command) ;; This lets you use your completion framework to search for comands after a prefix (eg: C-x C-h)
  :config
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** Indicator

#+begin_src emacs-lisp
(defun embark-which-key-indicator ()
  "An embark indicator that displays keymaps using which-key.
The which-key help message will show the type and value of the
current target followed by an ellipsis if there are further
targets."
  (lambda (&optional keymap targets prefix)
    (if (null keymap)
        (which-key--hide-popup-ignore-command)
      (which-key--show-keymap
       (if (eq (plist-get (car targets) :type) 'embark-become)
           "Become"
         (format "Act on %s '%s'%s"
                 (plist-get (car targets) :type)
                 (embark--truncate-target (plist-get (car targets) :target))
                 (if (cdr targets) "…" "")))
       (if prefix
           (pcase (lookup-key keymap prefix 'accept-default)
             ((and (pred keymapp) km) km)
             (_ (key-binding prefix 'accept-default)))
         keymap)
       nil nil t (lambda (binding)
                   (not (string-suffix-p "-argument" (cdr binding))))))))

(setq embark-indicators
  '(embark-which-key-indicator
    embark-highlight-indicator
    embark-isearch-highlight-indicator))

(defun embark-hide-which-key-indicator (fn &rest args)
  "Hide the which-key indicator immediately when using the completing-read prompter."
  (which-key--hide-popup-ignore-command)
  (let ((embark-indicators
         (remq #'embark-which-key-indicator embark-indicators)))
      (apply fn args)))

(advice-add #'embark-completing-read-prompter
            :around #'embark-hide-which-key-indicator)
#+end_src

* Org

Config:
#+begin_src emacs-lisp
;; Stright builds org from upstream and it has a version mismatch with other org packages. This instructs straight to use the org version shiped with emacs.
(use-package org :straight (:type built-in))

(setq org-edit-src-content-indentation 0
      org-startup-indented t
      org-ellipsis "  ")

;; This only works if the cursor is in the 'xxx:' part of the link
(defun +org-return ()
  (interactive)
  (if (string= (car (org-element-context)) "link")
      (org-open-at-point)
    (evil-ret)))

(with-eval-after-load 'evil-collection
  (evil-define-key* 'normal org-mode-map (kbd "RET") '+org-return)) ;; Make RET open links
#+end_src

** Markers

#+begin_src emacs-lisp
(use-package org-appear
  :hook
  (org-mode . org-appear-mode)
  :config
  (setq org-appear-trigger 'manual
        org-hide-emphasis-markers t
        org-appear-autolinks t
        org-pretty-entities t
        org-appear-autoentities t
        org-appear-autosubmarkers t)
  :init
  (add-hook 'org-mode-hook (lambda ()
                             (add-hook 'evil-insert-state-entry-hook
                                       #'org-appear-manual-start
                                       nil
                                       t)
                             (add-hook 'evil-insert-state-exit-hook
                                       #'org-appear-manual-stop
                                       nil
                                       t))))
#+end_src

** Superstar

#+begin_src emacs-lisp
(use-package org-superstar
  :hook (org-mode . org-superstar-mode))
#+end_src

** PDF

Open org links to PDF in pdf-tools.
#+begin_src emacs-lisp
(use-package org-pdftools
  :hook (org-mode . org-pdftools-setup-link))
#+end_src

** Transclusion

#+begin_src emacs-lisp
(use-package org-transclusion
  :after org
  :bind
  (("C-c t t" . org-transclusion-mode)
   ("C-c t a" . org-transclusion-add)))
#+end_src

** Sticky header

#+begin_src emacs-lisp
(use-package org-sticky-header
  :hook
  (org-mode . org-sticky-header-mode)
  :config
  (setq org-sticky-header-show-keyword nil
        org-sticky-header-heading-star ""
        org-sticky-header-full-path 'reversed))
#+end_src

* Shells
** Vterm

*Settings:*
#+begin_src emacs-lisp
(add-hook 'vterm-mode-hook #'hide-mode-line-mode)

;; Keybinding
(global-set-key (kbd "C-x t V") #'vterm)
#+end_src

*** Toggle

#+begin_src emacs-lisp
(use-package vterm-toggle
  :bind
  ("C-x t v" . vterm-toggle))
#+end_src

** Shell

*Settings:*
#+begin_src emacs-lisp
(add-hook 'shell-mode-hook #'hide-mode-line-mode)

;; Keybinding
(global-set-key (kbd "C-x t S") #'shell)
#+end_src

*** Toggle

#+begin_src emacs-lisp
(use-package shell-pop
  :bind
  ("C-x t s" . shell-pop))
#+end_src

** Eshell

*Settings:*
#+begin_src emacs-lisp
;; Avoid cursor going before prompt
(add-hook 'eshell-mode-hook #'(lambda () ;; Eshell overrides the map after initialization therefore we have to set it after.
                                (local-set-key (kbd "<home>") #'eshell-bol)))

;; Remove hscroll-margin in shells, otherwise you get jumpiness when the
;; cursor comes close to the left/right edges of the window.
(add-hook 'eshell-mode-hook #'(lambda ()
                              (setq-local hscroll-margin 0)))

(setq eshell-scroll-to-bottom-on-input 'all
      eshell-scroll-to-bottom-on-output 'all
      eshell-kill-processes-on-exit t
      eshell-hist-ignoredups t
      ;; don't record command in history if prefixed with whitespace
      ;; TODO Use `eshell-input-filter-initial-space' when Emacs 25 support is dropped
      eshell-input-filter (lambda (input) (not (string-match-p "\\`\\s-+" input)))
      ;; em-glob
      eshell-glob-case-insensitive t
      eshell-error-if-no-glob t)

;; Disable history mode search keybinding so it won't override consult bindings. Using consult directly is more powerful.
(add-hook 'eshell-mode-hook (lambda ()
                              (define-key eshell-hist-mode-map (kbd "M-s") nil)))

;; Remove modeline
(add-hook 'eshell-mode-hook #'hide-mode-line-mode)

;; Keybind
(global-set-key (kbd "C-x t E") #'eshell)

;; Alias
(defun eshell/ff (&rest args)
  (apply #'find-file args))

(defun eshell/fo (&rest args)
  (apply #'find-file-other-window args))
#+end_src

*** Toggle

#+begin_src emacs-lisp
(use-package eshell-toggle
  :bind
  ("C-x t e" . eshell-toggle))
#+end_src

*** Clear

#+begin_src emacs-lisp
(add-hook 'eshell-mode-hook (lambda ()
                              (defun eshell/clear ()
                                "Clear the eshell buffer."
                                (let ((inhibit-read-only t))
                                  (erase-buffer)
                                  (eshell/clear-scrollback)))))

(defun run-this-in-eshell (cmd)
  "Runs the command 'cmd' in eshell."
  (if (string= (derived-mode-p 'eshell-mode) "eshell-mode")
      (progn (end-of-buffer)
             (eshell-kill-input)
             (message (concat "Running in Eshell: " cmd))
             (insert cmd)
             (eshell-send-input)
             (end-of-buffer)
             (eshell-bol)
             (yank))))

(add-hook 'eshell-mode-hook #'(lambda ()
                                (local-set-key (kbd "C-l") #'(lambda ()
                                                               (interactive)
                                                               (run-this-in-eshell "clear")))))
#+end_src

*** Suggestions

#+begin_src emacs-lisp
(use-package esh-autosuggest
  :hook (eshell-mode . esh-autosuggest-mode))
#+end_src

*** Up

Quickly go to a specific parent directory in eshell. Just type a substring of the parent dir as an argument to eshell-up function.
#+begin_src emacs-lisp
(use-package eshell-up
  :config
  (setq eshell-up-ignore-case t)
  (defun eshell/up (&rest args)
    (apply #'eshell-up args)))
#+end_src

*** Help

This library adds the following help functions and support for Eshell:

+ =run-help= function inspired by Zsh
+ =eldoc= support

#+begin_src emacs-lisp
(use-package esh-help
  :init
  (setup-esh-help-eldoc))
#+end_src

*** TODO Aweshell

Awesome shell extension base on eshell with wonderful features!
#+begin_src emacs-lisp :tangle no
(use-package aweshell
  :straight (aweshell :type git :host github :repo "manateelazycat/aweshell"
                      :files ("aweshell.el" "eshell-did-you-mean.el"))
  :after esh-mode ;; Specifically esh-mode, not eshell
  :config
  (eshell-did-you-mean-setup)
  ;; HACK There is a known issue with `eshell-did-you-mean' where it does not
  ;;      work on first invocation, so we invoke it once manually by setting the
  ;;      last command and then calling the output filter.
  (setq eshell-last-command-name "catt")
  (eshell-did-you-mean-output-filter "catt: command not found"))
#+end_src

*** Bash completion

#+begin_src emacs-lisp
(use-package bash-completion)
#+end_src

*** Fish completion

#+begin_src emacs-lisp
(use-package fish-completion
  :hook (eshell-mode . fish-completion-mode)
  :init (setq fish-completion-fallback-on-bash-p t)
  :config
  ;; HACK Even with `fish-completion-fallback-on-bash-p' non-nil,
  ;;      `fish-completion--list-completions-with-desc' will throw an error if
  ;;      fish isn't installed (and so, will fail to fall back to bash), so we
  ;;      advise it to fail silently.
  (advice-add 'fish-completion--list-completions-with-desc :before-until #'(lambda (&rest _)
                                                                             (unless (executable-find "fish") ""))))
#+end_src

*** Syntax highlighting

Syntax highlighting for Eshell.
#+begin_src emacs-lisp
(use-package eshell-syntax-highlighting
  :after esh-mode ;; Specifically esh-mode, not eshell
  :init
  ;; Enable in all Eshell buffers.
  (eshell-syntax-highlighting-global-mode 1))
#+end_src

*** Corfu support

#+begin_src emacs-lisp
(defun corfu-send-shell (&rest _)
  "Send completion candidate when inside comint/eshell."
  (cond
   ((and (derived-mode-p 'eshell-mode) (fboundp 'eshell-send-input))
    (eshell-send-input))
   ((and (derived-mode-p 'comint-mode)  (fboundp 'comint-send-input))
    (comint-send-input))))

(advice-add #'corfu-insert :after #'corfu-send-shell)

(add-hook 'eshell-mode-hook
          #'(lambda ()
              (setq-local corfu-auto nil)
              (corfu-mode)))
#+end_src

*** Consult support

In order to support quick jumping to prompts in eshell via consult-outline we can set the outline-regexp appropriately in the eshell-mode.
#+begin_src emacs-lisp
(add-hook 'eshell-mode-hook (lambda () (setq outline-regexp eshell-prompt-regexp)))
#+end_src

*** Fancy prompt

Needed packages:
#+begin_src emacs-lisp
(use-package eshell-prompt-extras)
#+end_src

Custom banner:
#+begin_src emacs-lisp
(eval-after-load "eshell"
  (setq eshell-banner-message
        '(format "%s %s\n"
                 (propertize (format " %s " (string-trim (buffer-name)))
                             'face 'mode-line-highlight)
                 (propertize (current-time-string)
                             'face 'font-lock-keyword-face))))
#+end_src

**** Doom prompt

#+begin_src emacs-lisp :tangle no
(defun doom-call-process (command &rest args)
  "Execute COMMAND with ARGS synchronously.
Returns (STATUS . OUTPUT) when it is done, where STATUS is the returned error
code of the process and OUTPUT is its stdout output."
  (with-temp-buffer
    (cons (or (apply #'call-process command nil t nil (remq nil args))
              -1)
          (string-trim (buffer-string)))))

(defface +eshell-prompt-pwd '((t (:inherit font-lock-constant-face)))
  "TODO"
  :group 'eshell)

(defface +eshell-prompt-git-branch '((t (:inherit font-lock-regexp-grouping-construct)))
  "TODO"
  :group 'eshell)

(defun +eshell--current-git-branch ()
  ;; TODO Refactor me
  (cl-destructuring-bind (status . output)
      (doom-call-process "git" "symbolic-ref" "-q" "--short" "HEAD")
    (if (equal status 0)
        (format " [%s]" output)
      (cl-destructuring-bind (status . output)
          (doom-call-process "git" "describe" "--all" "--always" "HEAD")
        (if (equal status 0)
            (format " [%s]" output)
          "")))))

(defun +eshell-default-prompt-fn ()
  "Generate the prompt string for eshell. Use for `eshell-prompt-function'."
  (require 'shrink-path)
  (concat (if (bobp) "" "\n")
          (let ((pwd (eshell/pwd)))
            (propertize (if (equal pwd "~")
                            pwd
                          (abbreviate-file-name (shrink-path-file pwd)))
                        'face '+eshell-prompt-pwd))
          (propertize (+eshell--current-git-branch)
                      'face '+eshell-prompt-git-branch)
          (propertize " λ" 'face (if (zerop eshell-last-command-status) 'success 'error))
          " "))

(eval-after-load "eshell"
  ;; em-prompt
  (setq eshell-prompt-regexp "^.* λ "
        eshell-prompt-function #'+eshell-default-prompt-fn))
#+end_src

**** Many Icons prompt

Prompt from: [[http://www.modernemacs.com/post/custom-eshell/][Modern Emacs - Making eshell your own]]
#+begin_src emacs-lisp
(require 'dash)
(require 's)

(defmacro with-face (STR &rest PROPS)
  "Return STR propertized with PROPS."
  `(propertize ,STR 'face (list ,@PROPS)))

(defmacro esh-section (NAME ICON FORM &rest PROPS)
  "Build eshell section NAME with ICON prepended to evaled FORM with PROPS."
  `(setq ,NAME
         (lambda () (when ,FORM
                      (-> ,ICON
                          (concat esh-section-delim ,FORM)
                          (with-face ,@PROPS))))))

(defun esh-acc (acc x)
  "Accumulator for evaluating and concatenating esh-sections."
  (--if-let (funcall x)
      (if (s-blank? acc)
          it
        (concat acc esh-sep it))
    acc))

(defun esh-prompt-func ()
  "Build `eshell-prompt-function'"
  (concat esh-header
          (-reduce-from 'esh-acc "" eshell-funcs)
          "\n"
          eshell-prompt-string))

(defun check-empty-dir ()
  (if (directory-empty-p (eshell/pwd))
      (char-to-string ?)
    (char-to-string ?)))

(defun check-pyenv ()
  (if (boundp 'pyvenv-virtual-env-name)
      pyvenv-virtual-env-name))

(esh-section esh-dir
             (check-empty-dir)  ;  (get icon folder)
             (abbreviate-file-name (eshell/pwd))
             '(:inherit outline-3 :bold ultra-bold :underline t))

(esh-section esh-git
             ""  ;  (git icon)
             (magit-get-current-branch)
             '(:inherit outline-4))

(defun get-python-env ()
  (if (bound-and-true-p pyvenv-virtual-env-name)
      pyvenv-virtual-env-name
    (let* ((env-full-path (getenv "VIRTUAL_ENV"))
           (env-name (if (bound-and-true-p env-full-path)
                         (file-name-nondirectory env-full-path))))
      (if (bound-and-true-p env-name)
          (if (member env-name '("venv" ".venv" "env" ".env"))
              (file-name-nondirectory
               (directory-file-name
                (file-name-directory
                 (directory-file-name env-full-path))))
            env-name)))))

(esh-section esh-python
             ;; This will only update after the directory change therefore on the first entrance
             ;; the python enviroment will not be loaded and won't appear in the prompt until
             ;; the next line.
             ""  ;  (python icon)
             (get-python-env)
             '(:inherit outline-8))

(esh-section esh-clock
             ""  ;  (clock icon)
             (format-time-string "%H:%M" (current-time))
             '(:inherit outline-7))

;; Below I implement a "prompt number" section
(setq esh-prompt-num 0)
(add-hook 'eshell-exit-hook (lambda () (setq esh-prompt-num 0)))
(advice-add 'eshell-send-input :before
            (lambda (&rest args) (setq esh-prompt-num (cl-incf esh-prompt-num))))

(esh-section esh-num
             "\xf0c9"  ;  (list icon)
             (number-to-string esh-prompt-num)
             '(:inherit outline-1))

;; Separator between esh-sections
(setq esh-sep "  ")  ; or " | "

;; Separator between an esh-section icon and form
(setq esh-section-delim " ")

;; Eshell prompt header
(setq esh-header "\n╭─ ")  ; or "\n┌─"

;; Eshell prompt regexp and string. Unless you are varying the prompt by eg.
;; your login, these can be the same.
(setq eshell-prompt-regexp "╰─ ")   ; or "└─> "
(setq eshell-prompt-string "╰─ ")   ; or "└─> "

;; Choose which eshell-funcs to enable
(setq eshell-funcs (list esh-dir esh-git esh-python esh-clock esh-num))

;; Enable the new eshell prompt
(setq eshell-prompt-function 'esh-prompt-func)
#+end_src

* Dired

Load the extra dired libraries.
#+begin_src emacs-lisp
(require 'dired-x)
(require 'dired-aux)
#+end_src

Display options for dired. They are the same as the ls command:
#+begin_quote
=-A, --almost-all=
      do not list implied . and ..

=-l=    use a long listing format

=-h, --human-readable=
      with -l and -s, print sizes like 1K 234M 2G etc.

=-t=    sort by time, newest first; see --time

=--group-directories-first=
      roup directories before files;
#+end_quote

#+begin_src emacs-lisp
(setq dired-listing-switches "-Alht --group-directories-first")
#+end_src

** Subtree

This package defines function dired-subtree-insert which instead inserts the subdirectory directly below its line in the original listing, and indent the listing of subdirectory to resemble a tree-like structure (somewhat similar to tree(1) except the pretty graphics). The tree display is somewhat more intuitive than the default "flat" subdirectory manipulation provided by i.
#+begin_src emacs-lisp
(use-package dired-subtree
  :bind (:map dired-mode-map
              ("<tab>" . dired-subtree-toggle)))
#+end_src

** Filtering

#+begin_src emacs-lisp
(use-package dired-filter
  :bind
  (:map dired-mode-map
        ("C-c g" . dired-filter-group-mode))
  (:map dired-filter-group-mode-map
        ("<tab>" . nil) ;; Free unused keybinding
        ("C-<tab>" . dired-filter-group-forward-drawer)
        ("M-<tab>" . dired-filter-group-backward-drawer))
  :hook
  (dired-mode . dired-filter-group-mode)
  :custom
  (dired-filter-group-saved-groups
   '(("default"
      ("directory"
       (extension . "d.*"))
      ("html"
       (extension . ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml")))
      ("xml"
       (extension . ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata" "toml")))
      ("document"
       (extension . ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx")))
      ("markdown"
       (extension . ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt")))
      ("database"
       (extension . ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc")))
      ("media"
       (extension . ("mp3" "mp4" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac")))
      ("image"
       (extension . ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg")))
      ("log"
       (extension . ("log")))
      ("shell"
       (extension . ("awk" "bash" "bat" "sed" "sh" "zsh" "vim")))
      ("interpreted"
       (extension . ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js")))
      ("compiled"
       (extension . ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java")))
      ("executable"
       (extension . ("exe" "msi")))
      ("compressed"
       (extension . ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar")))
      ("packaged"
       (extension . ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp")))
      ("encrypted"
       (extension . ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem")))
      ("fonts"
       (extension . ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf")))
      ("partition"
       (extension . ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak")))
      ("vc"
       (extension . ("git" "gitignore" "gitattributes" "gitmodules")))
      ("executable-unix"
       (extension . "-.*x.*"))))))
#+end_src

** Collapse

Often times we find ourselves in a situation where a single file or directory is nested in a chain of nested directories with no other content. This is sometimes due to various mandatory layouts demanded by packaging tools or tools generating these deeply-nested "unique" paths to disambiguate architectures or versions (but we often use only one anyway). If the user wants to access these directories they have to quite needlessly drill-down through varying number of "uninteresting" directories to get to the content.
#+begin_src emacs-lisp
(use-package dired-collapse
  :hook
  (dired-mode . dired-collapse-mode))
#+end_src

** External open

This package adds a mechanism to add "hooks" to dired-find-file that will run before emacs tries its own mechanisms to open the file, thus enabling you to launch other application or code and suspend the default behaviour.
#+begin_src emacs-lisp
(use-package dired-open
  :bind (:map dired-mode-map
              ("C-<return>" . dired-open-xdg)
              ("C-c o" . dired-open-xdg)))
#+end_src

** Ranger

This package implements useful features present in the ranger file manager which are missing in dired. This includes multi-stage copying with ~dired-ranger-copy~
#+begin_src emacs-lisp
(use-package dired-ranger
  :bind (:map dired-mode-map
              ("C-c y" . dired-ranger-copy)
              ("C-c p" . dired-ranger-paste)
              ("C-c m" . dired-ranger-move)))
#+end_src

** Rsync

This repository provides a transient version called dired-transient-rsync. This wraps the command in a `magit` like transient interface allowing you to tweaks the parameters for your call.
#+begin_src emacs-lisp
(use-package dired-rsync
  :bind (:map dired-mode-map
              ("C-c r" . dired-rsync-transient)))
#+end_src

** Theming

*** Icons

Add icons (match the ones used in treemacs).
#+begin_src emacs-lisp
(use-package treemacs-icons-dired
  :hook (dired-mode . treemacs-icons-dired-enable-once))
#+end_src

*** Extra font locks

Extra font lock rules for a more colourful dired (eg. font lock on permissions).
#+begin_src emacs-lisp
(use-package diredfl
  :init
  (diredfl-global-mode))
#+end_src

* PDF

#+begin_src emacs-lisp
(use-package pdf-tools
  :config
  (pdf-tools-install)
  :bind (:map pdf-view-mode-map
              ("\\" . hydra-pdftools/body)
              ("<s-spc>" .  pdf-view-scroll-down-or-next-page)
              ("g"  . pdf-view-first-page)
              ("G"  . pdf-view-last-page)
              ("l"  . image-forward-hscroll)
              ("h"  . image-backward-hscroll)
              ("j"  . pdf-view-next-page)
              ("k"  . pdf-view-previous-page)
              ("e"  . pdf-view-goto-page)
              ("u"  . pdf-view-revert-buffer)
              ("al" . pdf-annot-list-annotations)
              ("ad" . pdf-annot-delete)
              ("aa" . pdf-annot-attachment-dired)
              ("am" . pdf-annot-add-markup-annotation)
              ("at" . pdf-annot-add-text-annotation)
              ("y"  . pdf-view-kill-ring-save)
              ("i"  . pdf-misc-display-metadata)
              ("s"  . pdf-occur)
              ("b"  . pdf-view-set-slice-from-bounding-box)
              ("r"  . pdf-view-reset-slice)))

;; Hydra menu
(defhydra hydra-pdftools (:color blue :hint nil)
        "
                                                                      ╭───────────┐
       Move  History   Scale/Fit     Annotations  Search/Link    Do   │ PDF Tools │
   ╭──────────────────────────────────────────────────────────────────┴───────────╯
         ^^_g_^^      _B_    ^↧^    _+_    ^ ^     [_al_] list    [_s_] search    [_u_] revert buffer
         ^^^↑^^^      ^↑^    _H_    ^↑^  ↦ _W_ ↤   [_am_] markup  [_o_] outline   [_i_] info
         ^^_p_^^      ^ ^    ^↥^    _0_    ^ ^     [_at_] text    [_F_] link      [_d_] dark mode
         ^^^↑^^^      ^↓^  ╭─^─^─┐  ^↓^  ╭─^ ^─┐   [_ad_] delete  [_f_] search link
    _h_ ←pag_e_→ _l_  _N_  │ _P_ │  _-_    _b_     [_aa_] dired
         ^^^↓^^^      ^ ^  ╰─^─^─╯  ^ ^  ╰─^ ^─╯   [_y_]  yank
         ^^_n_^^      ^ ^  _r_eset slice box
         ^^^↓^^^
         ^^_G_^^
   --------------------------------------------------------------------------------
        "
        ("\\" hydra-master/body "back")
        ("<ESC>" nil "quit")
        ("al" pdf-annot-list-annotations)
        ("ad" pdf-annot-delete)
        ("aa" pdf-annot-attachment-dired)
        ("am" pdf-annot-add-markup-annotation)
        ("at" pdf-annot-add-text-annotation)
        ("y"  pdf-view-kill-ring-save)
        ("+" pdf-view-enlarge :color red)
        ("-" pdf-view-shrink :color red)
        ("0" pdf-view-scale-reset)
        ("H" pdf-view-fit-height-to-window)
        ("W" pdf-view-fit-width-to-window)
        ("P" pdf-view-fit-page-to-window)
        ("n" pdf-view-next-page-command :color red)
        ("p" pdf-view-previous-page-command :color red)
        ("d" pdf-view-dark-minor-mode)
        ("b" pdf-view-set-slice-from-bounding-box)
        ("r" pdf-view-reset-slice)
        ("g" pdf-view-first-page)
        ("G" pdf-view-last-page)
        ("e" pdf-view-goto-page)
        ("o" pdf-outline)
        ("s" pdf-occur)
        ("i" pdf-misc-display-metadata)
        ("u" pdf-view-revert-buffer)
        ("F" pdf-links-action-perfom)
        ("f" pdf-links-isearch-link)
        ("B" pdf-history-backward :color red)
        ("N" pdf-history-forward :color red)
        ("l" image-forward-hscroll :color red)
        ("h" image-backward-hscroll :color red))
#+end_src

* DIFF

By default ediff spawns a new frame to display files to be compared or merged. Remove that. Also save window layout before ediff and restore on exit.
#+begin_src emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain
      ediff-split-window-function 'split-window-horizontally)

;; Some custom configuration to ediff
(defvar my-ediff-bwin-config nil "Window configuration before ediff.")
(defcustom my-ediff-bwin-reg ?b
  "*Register to be set up to hold `my-ediff-bwin-config'
    configuration.")

(defvar my-ediff-awin-config nil "Window configuration after ediff.")
(defcustom my-ediff-awin-reg ?e
  "*Register to be used to hold `my-ediff-awin-config' window
    configuration.")

(defun my-ediff-bsh ()
  "Function to be called before any buffers or window setup for
    ediff."
  (setq my-ediff-bwin-config (current-window-configuration))
  (when (characterp my-ediff-bwin-reg)
    (set-register my-ediff-bwin-reg
                  (list my-ediff-bwin-config (point-marker)))))

(defun my-ediff-ash ()
  "Function to be called after buffers and window setup for ediff."
  (setq my-ediff-awin-config (current-window-configuration))
  (when (characterp my-ediff-awin-reg)
    (set-register my-ediff-awin-reg
                  (list my-ediff-awin-config (point-marker)))))

(defun my-ediff-qh ()
  "Function to be called when ediff quits."
  (when my-ediff-bwin-config
    (set-window-configuration my-ediff-bwin-config)))

(add-hook 'ediff-before-setup-hook 'my-ediff-bsh)
(add-hook 'ediff-after-setup-windows-hook 'my-ediff-ash 'append)
(add-hook 'ediff-quit-hook 'my-ediff-qh)
#+end_src

* Compilation

#+begin_src emacs-lisp
(global-set-key (kbd "C-x c") #'(lambda  ()
                                  (interactive)
                                  (let ((current-prefix-arg '(4))) ;; C-u
                                    (call-interactively 'compile))))

(put 'compile-command 'safe-local-variable #'booleanp) ;; Allow compile-command to be a safe variable (this is dangerous be cautious with what you allow to run)

(add-to-list 'compilation-error-regexp-alist '("^devicetree error: \\(.*?\\):\\([0-9]+\\)" 1 2))

(evil-define-key* 'normal compilation-shell-minor-mode-map "q" 'quit-window) ;; Allow closing compilation buffers by pressing q
(define-key compilation-shell-minor-mode-map (kbd "C-c q") 'quit-window) ;; Add a keybinding also for emacs mode
#+end_src

* Project management
** Projectile

Add project management to emacs.
#+begin_src emacs-lisp
(use-package projectile
  :bind (("C-c p" . projectile-command-map))
  :init
  (projectile-mode))
#+end_src

** Direnv

#+begin_src emacs-lisp
(use-package direnv
  :init
  (direnv-mode))
#+end_src

* Extras
** Nicieties

#+begin_src emacs-lisp
;; Emacs 28: Hide commands in M-x which do not work in the current mode.
;; Vertico commands are hidden in normal buffers.
(setq read-extended-command-predicate #'command-completion-default-include-p
      enable-recursive-minibuffers t)

(defun +reload-emacs ()
    "Reload the Emacs configuration"
    (interactive)
    (load-file "~/.emacs.d/init.el"))

;; Supress warnings but enable them on debug
(if init-file-debug
      (setq warning-minimum-level :debug)
    (setq warning-minimum-level :emergency))
#+end_src

*** Autorevert

#+begin_src emacs-lisp
(setq auto-revert-interval 0.5
      global-auto-revert-non-file-buffers t ;; Revert buffers like Dired
      auto-revert-verbose nil) ;; Don't ask when reverting

(define-key override-global-map (kbd "C-x r b") #'revert-buffer)

;; Auto revert files when they change
(global-auto-revert-mode t)
#+end_src

** Handle very long lines

When the lines in a file are so long that performance could suffer to an
unacceptable degree, we say "so long" to the slow modes and options enabled
in that buffer, and invoke something much more basic in their place.
#+begin_src emacs-lisp
(use-package so-long
  :hook (after-init-hook . global-so-long-mode))
#+end_src

** Scrolling

#+begin_src emacs-lisp
(setq scroll-step 1
      scroll-conservatively 101)
#+end_src

** Screenshot

#+begin_src emacs-lisp
(use-package screenshot
  :straight (screenshot :type git :host github :repo "tecosaur/screenshot"))
#+end_src

** Crux

A Collection of Ridiculously Useful eXtensions for Emacs. crux bundles many useful interactive commands to enhance your overall Emacs experience.
#+begin_src emacs-lisp
(use-package crux
  :bind (("C-x O" . crux-open-with)
         ("C-x U" . crux-view-url)
         ("C-x E" . crux-eval-and-replace)
         ("C-x D" . crux-delete-file-and-buffer)
         ("C-x C" . crux-copy-file-preserve-attributes)
         ("C-x R" . crux-rename-file-and-buffer)))
#+end_src

** Inherit shell

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :init
  (when (memq window-system '(mac ns x))
  (exec-path-from-shell-initialize)))
#+end_src

** Log keys

Mode to log every key press in emacs with the corresponding action taken.
#+begin_src emacs-lisp
(use-package command-log-mode)
#+end_src

* Programming
** Formaters
*** Clang-format

#+begin_src emacs-lisp
(use-package clang-format+
  :hook (c-mode-common . clang-format+-mode))
#+end_src

This offers formating of the buffer but the emacs editing style remains unchanges so hitting TAB might not align with what .Clang-format specifies. Here is a function to set the emacs formating style according to the .clang-format
#+begin_src emacs-lisp
(require 's) ;; Needed for s-match, load it first

(defun get-clang-format-option (config-str field is-num)
  "Retrieve a config option from a clang-format config.

CONFIG-STR is a string containing the entire clang-format config.
FIELD is specific option, e.g. `IndentWidth'.  IS-NUM is a
boolean that should be set to 1 if the option is numeric,
otherwise assumed alphabetic."
  (if is-num
      (let ((primary-match (s-match (concat "^" field ":[ \t]*[0-9]+") config-str)))
        (if primary-match
            (string-to-number (car (s-match "[0-9]+" (car primary-match))))
          0))
    (let ((primary-match (s-match (concat "^" field ":[ \t]*[A-Za-z]+") config-str)))
      (if primary-match
          (car (s-match "[A-Za-z]+$" (car primary-match)))
        ""))))

(add-hook 'c-mode-common-hook  #'(lambda ()
                              (let* ((clang-format-config
                                      (shell-command-to-string "clang-format -dump-config"))
                                     (c-offset (get-clang-format-option clang-format-config "IndentWidth" t))
                                     (tabs-str (get-clang-format-option clang-format-config "UseTab" nil))
                                     (base-style
                                      (get-clang-format-option clang-format-config "BasedOnStyle" nil)))
                                (progn
                                  (if (> c-offset 0)
                                      (setq-local c-basic-offset c-offset)
                                    (if (not (equal "" base-style))
                                        (cond ((or (equal "LLVM" base-style)
                                                   (equal "Google" base-style)
                                                   (equal "Chromium" base-style)
                                                   (equal "Mozilla" base-style))
                                               (setq-local c-basic-offset 2))
                                              ((equal "WebKit" base-style)
                                               (setq-local c-basic-offset 4)))))
                                  (if (not (equal "" tabs-str))
                                      (if (not (string-equal "Never" tabs-str))
                                          (setq-local indent-tabs-mode t)
                                        (setq-local indent-tabs-mode nil))
                                    (if (not (equal "" base-style))
                                        (cond ((or (equal "LLVM" base-style)
                                                   (equal "Google" base-style)
                                                   (equal "Chromium" base-style)
                                                   (equal "Mozilla" base-style)
                                                   (equal "WebKit" base-style))
                                               (setq-local indent-tabs-mode nil)))))))))
#+end_src

** Syntax highlighters
*** Tree-sitter

Tree-sitter is a parser generator tool and an incremental parsing library. It can build a concrete syntax tree for a source file and efficiently update the syntax tree as the source file is edited.
#+begin_src emacs-lisp
(use-package tree-sitter
  :hook
  (tree-sitter-after-on . tree-sitter-hl-mode)
  :config
  (custom-set-faces ;; Adjust faces to a more resonable default.
   ;;;;; tree-sitter
   `(tree-sitter-hl-face:method.call          ((t (:inherit font-lock-function-name-face))))
   `(tree-sitter-hl-face:function.call        ((t (:inherit font-lock-function-name-face))))
   `(tree-sitter-hl-face:operator             ((t (:inherit default))))
   `(tree-sitter-hl-face:type.builtin         ((t (:inherit font-lock-keyword-face))))
   `(tree-sitter-hl-face:number               ((t (:inherit highlight-numbers-number))))
   `(tree-sitter-hl-face:variable.special     ((t (:inherit font-lock-keyword-face)))))
  :init
  (global-tree-sitter-mode))

(use-package tree-sitter-langs
  :after tree-sitter)
#+end_src

*** Prism

Prism disperses lisp forms (and other languages) into a spectrum of color by depth. It’s similar to rainbow-blocks, but it respects existing non-color face properties, and allows flexible configuration of faces and colors. It also optionally colorizes strings and/or comments by code depth in a similar, customizable way.
#+begin_src emacs-lisp
(use-package prism)
#+end_src

If the colors are not pleasant use =prism-randomize-colors=.

** Syntax checkers
*** Flymake
Flymake is the built-in Emacs package to support on-the-fly syntax checking.

One of the libraries provided by this package ~package-lint-flymake.el~ adds support for flymake to `package-lint'.
#+begin_src emacs-lisp
(use-package package-lint
  :straight (package-lint :files ("*.el" ("data/stdlib-changes" . "data/stdlib-changes"))))
#+end_src

_Note_: Straight usage from ~<C-h o> straight-expand-files-directive~.
#+begin_quote
FILES is a list, or nil. Each element of FILES can be a string, a
cons cell, a list, or the symbol :defaults.

...

If an entry is a cons cell, then it is taken as a literal mapping
from a file in SRC-DIR to a file in DEST-DIR (the directory is
not removed). In this case, wildcard expansion does not take
place.
#+end_quote

*** Flycheck

Use the more modern syntax checker (Flycheck) over the built-in Flymake. LSP mode will automatically pick it up.
#+begin_src emacs-lisp
(use-package flycheck)

;; This library provides a flycheck checker for the metadata in Emacs Lisp files which are intended to be packages. That metadata includes the package description, its dependencies and more. The checks are performed by the separate package-lint library.
(use-package flycheck-package
  :after flycheck
  :init
  (flycheck-package-setup))
#+end_src

*** TODO Elsa

Elsa (Emacs Lisp Static Analyser) is a tool that analyses your code without loading or running it. It can track types and provide helpful hints when things don't match up before you even try to run the code.
#+begin_src emacs-lisp :tangle no
(use-package elsa)
(use-package flycheck-elsa) ;; Integration of Elsa into Flycheck.
#+end_src

** Language server providers
*** Eglot

Lightweight LSP client.
#+begin_src emacs-lisp
(use-package eglot)
#+end_src

*** TODO LSP

Full fledged LSP client.
#+begin_src emacs-lisp
(use-package lsp-mode
  :hook
  (lsp-mode . lsp-enable-which-key-integration)
  :custom
  (lsp-keymap-prefix "C-c l")
  (lsp-completion-provider :none) ;; Remove the providers so Corfu can take precedence.
  :init
  (lsp-dired-mode))
#+end_src

**** Change priority

#+begin_src emacs-lisp
(defun doom-unquote (exp)
  "Return EXP unquoted."
  (declare (pure t) (side-effect-free t))
  (while (memq (car-safe exp) '(quote function))
    (setq exp (cadr exp)))
  exp)

(defmacro add-transient-hook! (hook-or-function &rest forms)
  "Attaches a self-removing function to HOOK-OR-FUNCTION.

FORMS are evaluated once, when that function/hook is first invoked, then never
again.

HOOK-OR-FUNCTION can be a quoted hook or a sharp-quoted function (which will be
advised)."
  (declare (indent 1))
  (let ((append? (if (eq (car forms) :after) (pop forms)))
        (fn (gensym "doom-transient-hook")))
    `(let ((sym ,hook-or-function))
       (defun ,fn (&rest _)
         ,(format "Transient hook for %S" (doom-unquote hook-or-function))
         ,@forms
         (let ((sym ,hook-or-function))
           (cond ((functionp sym) (advice-remove sym #',fn))
                 ((symbolp sym)   (remove-hook sym #',fn))))
         (unintern ',fn nil))
       (cond ((functionp sym)
              (advice-add ,hook-or-function ,(if append? :after :before) #',fn))
             ((symbolp sym)
              (put ',fn 'permanent-local-hook t)
              (add-hook sym #',fn ,append?))))))

(defun +lsp/switch-client (client)
  "Switch to another LSP server."
  (interactive
   (progn
     (require 'lsp-mode)
     (list (completing-read
            "Select server: "
            (or (mapcar #'lsp--client-server-id (lsp--filter-clients (-andfn #'lsp--supports-buffer?
                                                                             #'lsp--server-binary-present?)))
                (user-error "No available LSP clients for %S" major-mode))))))
  (require 'lsp-mode)
  (let* ((client (if (symbolp client) client (intern client)))
         (match (car (lsp--filter-clients (lambda (c) (eq (lsp--client-server-id c) client)))))
         (workspaces (lsp-workspaces)))
    (unless match
      (user-error "Couldn't find an LSP client named %S" client))
    (let ((old-priority (lsp--client-priority match)))
      (setf (lsp--client-priority match) 9999)
      (unwind-protect
          (if workspaces
              (lsp-workspace-restart
               (if (cdr workspaces)
                   (lsp--completing-read "Select server: "
                                         workspaces
                                         'lsp--workspace-print
                                         nil t)
                 (car workspaces)))
            (lsp-mode +1))
       (add-transient-hook! 'lsp-after-initialize-hook
          (setf (lsp--client-priority match) old-priority))))))
#+end_src


**** UI

Fancy sideline, popup documentation, VScode-like peek UI, etc.
#+begin_src emacs-lisp
(use-package lsp-ui
  :after lsp-mode
  :bind (:map lsp-ui-mode-map
              ([remap xref-find-definitions] . lsp-ui-peek-find-definitions)
              ([remap xref-find-references] . lsp-ui-peek-find-references)))
#+end_src

**** Consult

Mimic a few features of helm-lsp and lsp-ivy in consult workflow.
#+begin_src emacs-lisp
(use-package consult-lsp
  :after lsp-mode
  :bind (:map lsp-mode-map
              ([remap xref-find-apropos] . consult-lsp-symbols)))
#+end_src

** Debuggers

*** TODO DAP

#+begin_src emacs-lisp
(use-package dap-mode
  :init
  (dap-auto-configure-mode))
#+end_src

** Elisp
*** Suggestions

suggest.el is an Emacs package for discovering elisp functions based on examples. You supply an example input and output, and it makes suggestions.
#+begin_src emacs-lisp
(use-package suggest)
#+end_src

** Python

Load the python debugger library.
#+begin_src emacs-lisp
(require 'dap-python)
#+end_src

*** Language servers
**** Pyright

#+begin_src emacs-lisp
(use-package lsp-pyright)
#+end_src

*** Environments

#+begin_src emacs-lisp
(use-package pyvenv
  :init
  (pyvenv-mode)
  (pyvenv-tracking-mode))
#+end_src

** C
*** Language servers
**** CCLS

This is needed to provide support for CCLS to LSP-mode.
#+begin_src emacs-lisp
(use-package ccls)
#+end_src

** HTML
*** Htmlize

This package converts the buffer text and the associated decorations to HTML. It allows org export to colorize src blocks
#+begin_src emacs-lisp
(use-package htmlize)
#+end_src

** JSON

#+begin_src emacs-lisp
(use-package json-mode)
#+end_src

** YAML

#+begin_src emacs-lisp
(use-package yaml-mode)
#+end_src

** Makefile

Emacs helpers to run things from makefiles.
#+begin_src emacs-lisp
(use-package makefile-executor
  :config
  (add-hook 'makefile-mode-hook 'makefile-executor-mode))
#+end_src

** DTS

This provides basic editing support for DTS files.
#+begin_src emacs-lisp
(use-package dts-mode
  :config
  (add-to-list 'auto-mode-alist '("\\.keymap\\'" . dts-mode)))
#+end_src

** Nix

#+begin_src emacs-lisp
(use-package nix-mode
  :mode "\\.nix\\'"
  :config
  ;; Since we are using corfu for completion give enough time to fetch everything before flooding the repl with the live output
  ;; Yes it seems that the repl is implemented in a way in which if the time for fetching completion excedes the maximum it starts
  ;; to print all of it into the buffer. Let corfu handle long outputs.
  (setq nix-repl-completion-output-timeout 10000))
#+end_src

** Docker

#+begin_src emacs-lisp
(use-package dockerfile-mode)
#+end_src

*** TRAMP

Offers the TRAMP method docker to access running containers:
#+begin_src emacs-lisp
(use-package docker-tramp)
#+end_src

#+begin_quote
=C-x C-f= /docker:user@container:/path/to/file

_where_:
  =user=           is the user that you want to use inside the container (optional)
  =container=      is the id or name of the container
#+end_quote

* TODO [2/7] [28%]
+ [ ] Winner undoo
+ [ ] Change focus
+ [ ] Popper
+ [ ] Shackles
+ [ ] Ediff opens control window in a new frame
+ [ ] Evil-collection should provide bindings for diff-hl
+ [X] Eshell is slow on the first command (some icons are slow to load)
+ [X] Org-ret open at point now it wont oppen unless is litteraly inside of the link part not on the description
