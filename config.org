#+title: Custom Vanilla Config
#+author: Sergio Pastor Pérez
#+startup: showeverything

* Package manager

Initialize the package manager:
#+begin_src emacs-lisp
;; Stright.el support
(setq straight-use-package-by-default t)
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 6))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
(straight-use-package 'use-package)
#+end_src

* Presonal information

#+begin_src emacs-lisp
(setq user-full-name "Sergio Pastor Pérez"
      user-mail-address "sergio.pastorperez@gmail.com")
#+end_src

* UI

Config:
#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(show-paren-mode 1)
(blink-cursor-mode 0)
(scroll-bar-mode -1)
(global-visual-line-mode 1)

(defalias 'yes-or-no-p 'y-or-n-p)

(setq x-stretch-cursor t
      initial-scratch-message nil
      inhibit-default-init t
      inhibit-startup-screen t
      inhibit-startup-echo-area-message t)

(add-hook 'prog-mode-hook #'display-line-numbers-mode)
#+end_src

** Fix defaults

In emacs for history reasons C-i is the same key as TAB. This is a problem inherited from terminal emulators. Using GUI we can do better:
#+begin_src emacs-lisp
;; Fix TAB and C-i (only in GUI)
(define-key input-decode-map [(control ?i)] [control-i])
(define-key input-decode-map [(control ?I)] [(shift control-i)])
#+end_src

Escape with ESC:
#+begin_src emacs-lisp
;; Make ESC close prompts
(global-set-key (kbd "<escape>") #'keyboard-escape-quit)
#+end_src

** Window management

#+begin_src emacs-lisp :tangle no
;; Create prefix
(define-prefix-command '+window-map)
(define-key +window-map (kbd "w") #'evil-window-next)
(define-key +window-map (kbd "W") #'evil-window-prev)
(define-key +window-map (kbd "C-W") #'evil-window-prev)
(define-key +window-map (kbd "C-w") #'evil-window-next)
(define-key +window-map (kbd "r") #'evil-window-rotate-downwards)
(define-key +window-map (kbd "R") #'evil-window-rotate-upwards)
(define-key +window-map (kbd "C-r") #'evil-window-rotate-downwards)
(define-key +window-map (kbd "C-R") #'evil-window-rotate-upwards)
(define-key +window-map (kbd "=") #'balance-windows)
(define-key +window-map (kbd "a") #'ace-window)

;; Unbind evil-keybinds and bind +window-map
(with-eval-after-load 'evil-maps
  (dolist (map '(evil-motion-state-map
                 evil-insert-state-map
                 evil-emacs-state-map))
    (define-key (eval map) (kbd "C-w") +window-map)))
#+end_src


*** Winner
Winner Mode is a global minor mode that allows you to “undo” and “redo” changes in WindowConfiguration.
#+begin_src emacs-lisp
(add-hook 'after-init-hook 'winner-mode)
#+end_src

*** Ibuffer

#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-b") #'ibuffer-other-window)
#+end_src

**** Icons

#+begin_src emacs-lisp
(use-package all-the-icons-ibuffer
  :hook (ibuffer-mode . all-the-icons-ibuffer-mode))
#+end_src

**** VC

Show files separated on version controlled projects.
#+begin_src emacs-lisp
(use-package ibuffer-vc
  :hook
  (ibuffer-mode . (lambda ()
                    (ibuffer-vc-set-filter-groups-by-vc-root)
                    (unless (eq ibuffer-sorting-mode 'alphabetic)
                      (ibuffer-do-sort-by-alphabetic)))))

(setq ibuffer-formats
      '((mark modified read-only vc-status-mini " "
              (name 18 18 :left :elide)
              " "
              (size 9 -1 :right)
              " "
              (mode 16 16 :left :elide)
              " "
              (vc-status 16 16 :left)
              " "
              vc-relative-file)))
#+end_src

*** TODO Popper

#+begin_src emacs-lisp
(use-package popper
  :bind (("C-x t l"   . popper-toggle-latest)
         ("C-x t n"   . popper-cycle)
         ("C-x t t" . popper-toggle-type))
  :init
  (setq popper-reference-buffers '("\\*Messages\\*"
                                   "Output\\*$"
                                   "\\*Async Shell Command\\*"
                                   help-mode
                                   helpful-mode
                                   ibuffer-mode
                                   compilation-mode)
        popper-display-function nil
        popper-mode-line (propertize " POP " 'face 'mode-line-emphasis)
        popper-echo-dispatch-keys '("C-0" "C-1" "C-2" "C-3" "C-4"
                                    "C-5" "C-6" "C-7" "C-8" "C-9"))
  (popper-mode +1)
  (popper-echo-mode +1)) ; For echo area hints
#+end_src

*** TODO Shackles

This seems to be the only rule that works:
#+begin_src emacs-lisp
(use-package shackle)
(setq shackle-rules '((compilation-mode :noselect t))
        shackle-default-rule '(:select t))

(shackle-mode)
#+end_src

** Highlighting
*** Line

Only highlight prog & text buffers
#+begin_src emacs-lisp
(use-package hl-line
  :hook
  (prog-mode . hl-line-mode)
  (text-mode . hl-line-mode))
#+end_src

*** Numbers

#+begin_src emacs-lisp
(use-package highlight-numbers
  :hook
  (prog-mode . highlight-numbers-mode))
#+end_src

*** Parenthesis

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook
  ;; (eshell-mode . rainbow-delimiters-mode) ;; Breaks eshell prompt coloring
  (prog-mode . rainbow-delimiters-mode))
#+end_src

*** Quoted

#+begin_src emacs-lisp
(use-package highlight-quoted
  :straight (highlight-quoted :type git :host github :repo "Fanael/highlight-quoted")
  :hook
  (emacs-lisp-mode . highlight-quoted-mode))
#+end_src

*** Defined

#+begin_src emacs-lisp
(use-package highlight-defined
  :hook
  ;; (eshell-mode . rainbow-delimiters-mode) ;; Breaks eshell prompt coloring
  (emacs-lisp-mode . highlight-defined-mode))
#+end_src


*** VC fringe diff

#+begin_src emacs-lisp
(use-package diff-hl
  :hook
  (dired-mode . diff-hl-dired-mode)
  (magit-pre-refresh . diff-hl-magit-pre-refresh)
  (magit-post-refresh . diff-hl-magit-post-refresh)
  :custom
  (diff-hl-side 'right)
  :config
  (with-eval-after-load 'evil-collection
    (evil-define-key* 'normal diff-hl-inline-popup-transient-mode-map "q" 'diff-hl-inline-popup-hide)
    (evil-define-key* 'normal diff-hl-inline-popup-transient-mode-map "p" 'diff-hl-show-hunk-previous)
    (evil-define-key* 'normal diff-hl-inline-popup-transient-mode-map "n" 'diff-hl-show-hunk-next)
    (evil-define-key* 'normal diff-hl-inline-popup-transient-mode-map "r" 'diff-hl-show-hunk-revert-hunk)
    (evil-define-key* 'normal diff-hl-inline-popup-transient-mode-map "c" 'diff-hl-show-hunk-copy-original-text))
  :init
  (global-diff-hl-mode)
  (diff-hl-flydiff-mode)
  (diff-hl-show-hunk-mouse-mode))
#+end_src

** Minimap

#+begin_src emacs-lisp
(use-package minimap
  :config
  (setq minimap-window-location 'right
        minimap-minimum-width 10
        minimap-dedicated-window nil
        minimap-hide-cursor nil
        minimap-hide-scroll-bar t
        minimap-hide-fringes t))

#+end_src

** Hydra

#+begin_src emacs-lisp
(use-package hydra)
#+end_src

** Treemacs

#+begin_src emacs-lisp
(use-package treemacs
  :bind (("C-x t 1"   . treemacs-delete-other-windows)
         ("C-x t t"   . treemacs)
         ("C-x t d"   . treemacs-select-directory)
         ("C-x t B"   . treemacs-bookmark)
         ("C-x t C-t" . treemacs-find-file)
         ("C-x t M-t" . treemacs-find-tag)))

(use-package treemacs-evil
  :after (treemacs evil))

(use-package treemacs-projectile
  :after (treemacs projectile))

(use-package treemacs-icons-dired
  :hook (dired-mode . treemacs-icons-dired-enable-once))

(use-package treemacs-magit
  :after (treemacs magit))
#+end_src

** Eros

#+begin_src emacs-lisp
(use-package eros
  :init
  (eros-mode))
#+end_src

* Theming
** Modeline

#+begin_src emacs-lisp
(use-package doom-modeline
  :custom
  (doom-modeline-buffer-file-name-style 'truncate-upto-project)
  :init (doom-modeline-mode 1))

(use-package hide-mode-line)
#+end_src

** Color schemes

#+begin_src emacs-lisp
(setq custom-safe-themes t)
(with-eval-after-load 'ef-themes
  (load-theme 'ef-night))
(with-eval-after-load 'kaolin-themes
  (kaolin-treemacs-theme))
#+end_src

*** Ef

#+begin_src emacs-lisp
(use-package ef-themes)
#+end_src

*** Doom

#+begin_src emacs-lisp
(use-package doom-themes
  :config
  ;; Global settings (defaults)
  (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
        doom-themes-enable-italic t) ; if nil, italics is universally disabled

  ;; Enable flashing mode-line on errors
  (doom-themes-visual-bell-config)
  ;; Enable custom neotree theme (all-the-icons must be installed!)
  (doom-themes-neotree-config)
  ;; or for treemacs users
  (setq doom-themes-treemacs-theme "doom-atom") ; use "doom-colors" for less minimal icon theme
  (doom-themes-treemacs-config)
  ;; Corrects (and improves) org-mode's native fontification.
  (doom-themes-org-config))
#+end_src

*** Kaolin

#+begin_src emacs-lisp
(use-package kaolin-themes
  :custom
  (kaolin-themes-italic-comments t))
#+end_src

*** Tron legacy

#+begin_src emacs-lisp
(use-package tron-legacy-theme
  :config
  (setq tron-legacy-theme-vivid-cursor t))
#+end_src

** Fonts

#+begin_src emacs-lisp
(setq default-frame-alist
   '((font . "JetBrainsMono Nerd Font-14")))
#+end_src

** Icons

#+begin_src emacs-lisp
(use-package all-the-icons
  :if (display-graphic-p)
  :config
  (if (not (x-list-fonts "all-the-icons"))
      (all-the-icons-install-fonts)))
#+end_src

* Editing functionality
** Tabs

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

** Mouse buttons

#+begin_src emacs-lisp
(with-eval-after-load 'evil-maps
  (define-key evil-motion-state-map (kbd "<mouse-8>") 'evil-jump-backward)
  (define-key evil-motion-state-map (kbd "<mouse-9>") 'evil-jump-forward))
#+end_src

** Evil

#+begin_src emacs-lisp
(use-package evil
  :demand t
  :bind
  (:map evil-motion-state-map
        ;; Unbound confliction keys
        ("C-e" . nil)
        ("C-y" . nil)
        ("TAB" . nil) ;; Remove the default binding so org-cycle can take precedence
        ;; Scrolling bindings
        ("C-<up>" . evil-scroll-line-up)
        ("C-<down>" . evil-scroll-line-down)
        ;; Jumping
        ("g D" . xref-find-definitions-other-window))
  (:map evil-normal-state-map
        ("C-." . nil)) ;; Remove the default binding so embark-act can take precedence
  :config
  (evil-mode 1)
  (evil-set-undo-system 'undo-tree)
  (mapc (lambda (mode)
          (evil-set-initial-state mode 'emacs))
        '(eww-mode
          profiler-report-mode
          pdf-view-mode))
  (define-key evil-motion-state-map (kbd "C-o") 'evil-jump-backward)
  (define-key evil-motion-state-map [control-i] 'evil-jump-forward) ;; In emacs normal C-i is tab. The remap is needed
  :init
  (setq evil-ex-substitute-global t     ; I like my s/../.. to by global by default
        evil-move-cursor-back nil       ; Don't move the block cursor when toggling insert mode
        evil-kill-on-visual-paste nil
        evil-want-keybinding nil))

(use-package evil-collection
  :after evil
  :init
  (with-eval-after-load 'evil-collection ;; After
    (setq evil-collection-mode-list (remq 'org evil-collection-mode-list)) ;; Remove org form the list, it's bugged in visual mode. This needs to be in :init to not be overrided by the default values when loaded
    (evil-collection-init))) ;; Enable for magit
#+end_src

*** Surround

#+begin_src emacs-lisp
(use-package evil-surround
  :after evil
  :config
  (global-evil-surround-mode 1))
#+end_src

*** Snipe

#+begin_src emacs-lisp
(use-package evil-snipe
  :after evil
  :config
  (evil-snipe-override-mode 1))
#+end_src

*** Googles

#+begin_src emacs-lisp
(use-package evil-goggles
  :after evil
  :config
  (evil-goggles-mode)

  ;; optionally use diff-mode's faces; as a result, deleted text
  ;; will be highlighed with `diff-removed` face which is typically
  ;; some red color (as defined by the color theme)
  ;; other faces such as `diff-added` will be used for other actions
  (evil-goggles-use-diff-faces)
  (setq evil-goggles-duration 0.1))
#+end_src

*** Multiedit (the keybind is not working)

#+begin_src emacs-lisp
(use-package evil-multiedit
  :after evil
  :config
  (evil-multiedit-default-keybinds)
  (evil-define-key* nil evil-multiedit-mode-map (kbd "C-c n") #'iedit-show/hide-context-lines)) 
#+end_src

*** Easymotion

#+begin_src emacs-lisp
(use-package evil-easymotion
  :bind (:map evilem-map
              ("SPC" . evil-avy-goto-char-timer))
  :init
  (evilem-default-keybindings "gs"))
#+end_src

** Expand region

#+begin_src emacs-lisp
(use-package expand-region
  :after evil
  :bind
  ("C-+" . er/expand-region))
#+end_src

** Avy

Avy is a GNU Emacs package for jumping to visible text using a char-based decision tree
#+begin_src emacs-lisp
(use-package avy)
#+end_src

** Iedit

#+begin_src emacs-lisp
(use-package iedit
  :init
  (set-face-attribute 'iedit-occurrence nil :inherit 'lazy-highlight)) ;; Set iedit face to one that won't collide with lsp-face-highlight-textual
#+end_src

* History
** Backups
Backup files preserve file contents prior to the current session.
Put backed-up files on a dedicated directory (avoids cluttering the working directory tree).
#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . "~/.saves")))
#+end_src

** Autosave

Auto-saving preserves the text from earlier in the current editing session.
Put autosave files on a dedicated directory (avoids cluttering the working directory tree).
#+begin_src emacs-lisp
(setq auto-save-file-name-transforms
      `((".*" ,(concat user-emacs-directory "auto-save/") t)))
#+end_src

** Save place

This means when you visit a file, point goes to the last place
where it was when you previously visited the same file.
#+begin_src emacs-lisp
(save-place-mode 1)
#+end_src

** Savehist

Persist history over Emacs restarts. Vertico sorts by history position.
#+begin_src emacs-lisp
(use-package savehist
  :init
  (savehist-mode))
#+end_src

** Undo-tree

Undo system that allows tree visualization.
#+begin_src emacs-lisp
(use-package undo-tree
  :init
  (global-undo-tree-mode)
  :config
  (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo"))
        undo-tree-visualizer-diff t))
#+end_src

* Help
** Helpful

Improved help system.
#+begin_src emacs-lisp
(use-package helpful
  :custom
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ("C-h f" . helpful-function)
  ([remap describe-symbol] . helpful-symbol)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-command] . helpful-command)
  ([remap describe-key] . helpful-key))
#+end_src

** Which-key

Key legend popup.
#+begin_src emacs-lisp
(use-package which-key
  :diminish
  :custom
  (which-key-idle-secondary-delay 0.01)
  :config
  (which-key-mode t))
#+end_src

* Completion
** Vertico

#+begin_src emacs-lisp
(use-package vertico
  :straight (:files (:defaults "extensions/*")) ;; Load the extensions
  ;; Create this types of visual transformations:
  ;; + ~/some/path//opt -> /opt
  ;; + /some/other/path/~/.config -> ~/.config
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)
  :custom
  (vertico-cycle t)
  :bind
  (:map vertico-map
  ("<prior>" . vertico-scroll-down)
  ("<next>" . vertico-scroll-up)
  ("<escape>" . minibuffer-keyboard-quit)
  ("RET" . vertico-directory-enter)
  ("DEL" . vertico-directory-delete-char)
  ("M-DEL" . vertico-directory-delete-word))
  :config
  (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
  (define-key override-global-map (kbd "C-'") #'vertico-repeat)
  :init
  (vertico-mode)
  (vertico-mouse-mode))
#+end_src

** Orderless

Allow fuzy search on the completion framework.
#+begin_src emacs-lisp
;; Optionally use the `orderless' completion style.
(use-package orderless
  :init
  ;; Configure a custom style dispatcher (see the Consult wiki)
  ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
  ;;       orderless-component-separator #'orderless-escapable-split-on-space)
  (setq completion-styles '(orderless basic)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Marginalia

Add contextual information on the completion menus.
#+begin_src emacs-lisp
(use-package marginalia
  :bind (("M-A" . marginalia-cycle)
         :map minibuffer-local-map
           ("M-A" . marginalia-cycle))
  :custom
    (marginalia-max-relative-age 0)
    (marginalia-align 'left)
  :init
    (marginalia-mode))
#+end_src

** Icons

Enable icons on the completion framework.
#+begin_src emacs-lisp
(use-package all-the-icons-completion
  :after (marginalia all-the-icons)
  :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
  :config (setq all-the-icons-scale-factor 1.0)
  :init (all-the-icons-completion-mode))
#+end_src

** Corfu

Autocompletion for inline text.
#+begin_src emacs-lisp
(use-package corfu
  :straight (:files (:defaults "extensions/*")) ;; Load the extensions
  ;; Optional customizations
  :custom
  (corfu-cycle t)                  ; Allows cycling through candidates
  (corfu-auto t)                   ; Enable auto completion
  (tab-always-indent 'complete)

  :bind (:map corfu-map
              ("C-SPC" . corfu-insert-separator)
              ("RET" . nil))
  :config
  (defun corfu-enable-always-in-minibuffer ()
    "Enable Corfu in the minibuffer if Vertico/Mct are not active."
    (unless (or (bound-and-true-p mct--active)
                (bound-and-true-p vertico--input))
      (setq-local corfu-auto t)
      (corfu-mode)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer)
  :init
  (global-corfu-mode)
  (corfu-history-mode))
#+end_src

*** Documentation popup

#+begin_src emacs-lisp
(use-package corfu-doc
  :after corfu
  :bind (:map corfu-map
              ("M-e" . corfu-doc-scroll-down)
              ("M-d" . corfu-doc-scroll-up)
              ("M-c" . corfu-doc-toggle))
  :hook (corfu-mode-hook . corfu-doc-mode))
#+end_src

*** Icons

#+begin_src emacs-lisp
(use-package kind-icon
  :after corfu
  :custom
  (kind-icon-default-face 'corfu-default) ; to compute blended backgrounds correctly
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src

*** Eshell support

#+begin_src emacs-lisp
(defun corfu-send-shell (&rest _)
  "Send completion candidate when inside comint/eshell."
  (cond
   ((and (derived-mode-p 'eshell-mode) (fboundp 'eshell-send-input))
    (eshell-send-input))
   ((and (derived-mode-p 'comint-mode)  (fboundp 'comint-send-input))
    (comint-send-input))))

(advice-add #'corfu-insert :after #'corfu-send-shell)

(add-hook 'eshell-mode-hook
          #'(lambda ()
              (setq-local corfu-auto nil)
              (corfu-mode)))
#+end_src

** Cape

#+begin_src emacs-lisp
(use-package cape
  ;; Bind dedicated completion commands
  ;; Alternative prefix keys: C-c p, M-p, M-+, ...
  :bind (("M-p p" . completion-at-point) ;; capf
         ("M-p t" . complete-tag)        ;; etags
         ("M-p d" . cape-dabbrev)        ;; or dabbrev-completion
         ("M-p h" . cape-history)
         ("M-p f" . cape-file)
         ("M-p k" . cape-keyword)
         ("M-p s" . cape-symbol)
         ("M-p a" . cape-abbrev)
         ("M-p i" . cape-ispell)
         ("M-p l" . cape-line)
         ("M-p w" . cape-dict)
         ("M-p \\" . cape-tex)
         ("M-p _" . cape-tex)
         ("M-p ^" . cape-tex)
         ("M-p &" . cape-sgml)
         ("M-p r" . cape-rfc1345))
  :init
  ;; Add `completion-at-point-functions', used by `completion-at-point'.
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file))
#+end_src

** Yasnippet

#+begin_src emacs-lisp
(use-package yasnippet
  :config
  (defun +yas/org-last-src-lang ()
    "Return the language of the last src-block, if it exists."
    (save-excursion
      (beginning-of-line)
      (when (re-search-backward "^[ \t]*#\\+begin_src" nil t)
        (org-element-property :language (org-element-context)))))
  :init (yas-global-mode 1))

(use-package yasnippet-snippets)
#+end_src

** Extras

#+begin_src emacs-lisp
(advice-add #'vertico--format-candidate :around
            (lambda (orig cand prefix suffix index _start)
              (setq cand (funcall orig cand prefix suffix index _start))
              (concat
               (if (= vertico--index index)
                   (propertize "» " 'face 'vertico-current)
                 "  ")
               cand)))

;; Add prompt indicator to `completing-read-multiple'.
;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
(defun crm-indicator (args)
  (cons (format "[CRM%s] %s"
                (replace-regexp-in-string
                 "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                 crm-separator)
                (car args))
        (cdr args)))
(advice-add #'completing-read-multiple :filter-args #'crm-indicator)
#+end_src

* Search
** Wgrep
wgrep allows you to edit a grep buffer and apply those changes to the file buffer like sed interactively. No need to learn sed script, just learn Emacs.
#+begin_src emacs-lisp
(use-package wgrep)
#+end_src

** Consult

Adds emacs wrappers on UNIX search commands.
#+begin_src emacs-lisp
(use-package consult
  ;; Replace bindings. Lazily loaded due by `use-package'.
  :bind (;; C-c bindings (mode-specific-map)
         ("C-c h" . consult-history)
         ("C-c m" . consult-mode-command)
         ("C-c k" . consult-kmacro)
         ;; C-x bindings (ctl-x-map)
         ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
         ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
         ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
         ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
         ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ("<help> a" . consult-apropos)            ;; orig. apropos-command
         ;; M-g bindings (goto-map)
         ("M-g e" . consult-compile-error)
         ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ;; M-s bindings (search-map)
         ("M-s d" . consult-find)
         ("M-s D" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
         ;; Minibuffer history
         :map minibuffer-local-map
         ("M-s" . consult-history)                 ;; orig. next-matching-history-element
         ("M-r" . consult-history))                ;; orig. previous-matching-history-element

  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI.
  :hook (completion-list-mode . consult-preview-at-point-mode)

  ;; The :init configuration is always executed (Not lazy)
  :init

  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)

  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config

  ;; Optionally configure preview. The default value
  ;; is 'any, such that any key triggers the preview.
  ;; (setq consult-preview-key 'any)
  ;; (setq consult-preview-key (kbd "M-."))
  ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
  ;; For some commands and buffer sources it is useful to configure the
  ;; :preview-key on a per-command basis using the `consult-customize' macro.
  (consult-customize
   consult-theme :preview-key '(:debounce 0.2 any)
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-file-register
   consult--source-recent-file consult--source-project-recent-file
   ;; :preview-key (kbd "M-.")
   :preview-key '(:debounce 0.4 any))

  ;; Optionally configure the narrowing key.
  ;; Both "<" and "C-+" work reasonably well.
  (setq consult-narrow-key "<") ;; (kbd "C-+")

  ;; Optionally make narrowing help available in the minibuffer.
  ;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

  ;; By default `consult-project-function' uses `project-root' from project.el.
  ;; Optionally configure a different project root function.
  ;; There are multiple reasonable alternatives to chose from.
  ;;;; 1. project.el (the default)
  ;; (setq consult-project-function #'consult--default-project--function)
  ;;;; 2. projectile.el (projectile-project-root)
  ;; (autoload 'projectile-project-root "projectile")
  ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
  ;;;; 3. vc.el (vc-root-dir)
  ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
  ;;;; 4. locate-dominating-file
  ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
)
#+end_src

*** Dir

Choose a directory and act on it.
#+begin_src emacs-lisp
(use-package consult-dir
  :bind (("C-x C-d" . consult-dir)
         :map vertico-map
         ("C-x C-d" . consult-dir)
         ("C-x C-j" . consult-dir-jump-file)))
#+end_src

** Dumb jump

A fantastic package that uses regex to find possible matches of the target at point
#+begin_src emacs-lisp
(use-package dumb-jump
  :config
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)) 
#+end_src

* Version control
** Magit

Magit is a complete text-based user interface to Git.
#+begin_src emacs-lisp
(use-package magit)
#+end_src

** Gitignore

#+begin_src emacs-lisp
(use-package gitignore
  :straight (gitignore :type git :host github :repo "syohex/emacs-gitignore"))
#+end_src

* Automatic insertions
** Smartparenthens

Improved parenthesis.
#+begin_src emacs-lisp
(use-package smartparens
  :config
  (require 'smartparens-config)
  (setq sp-highlight-pair-overlay nil ;; Do not highlight space between parentheses when they are inserted
        sp-ignore-modes-list (delete 'minibuffer-mode sp-ignore-modes-list)) ;; Enable in the minibuffer
  (sp-local-pair 'minibuffer-mode "'" nil :actions nil) ;; Disable pairing single quotes on minibuffer
  :bind (("M-i" . sp-forward-slurp-sexp)
         ("M-I" . sp-backward-slurp-sexp)
         ("M-o" . sp-forward-barf-sexp)
         ("M-O" . sp-backward-barf-sexp))
  :init
  (smartparens-global-mode))
#+end_src

* Embark

Embark makes it easy to choose a command to run based on what is near point, both during a minibuffer completion session (in a way familiar to Helm or Counsel users) and in normal buffers.
#+begin_src emacs-lisp
(use-package embark
  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'
  :init
  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command) ;; This lets you use your completion framework to search for comands after a prefix (eg: C-x C-h)
  :config
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** Indicator

#+begin_src emacs-lisp
(defun embark-which-key-indicator ()
  "An embark indicator that displays keymaps using which-key.
The which-key help message will show the type and value of the
current target followed by an ellipsis if there are further
targets."
  (lambda (&optional keymap targets prefix)
    (if (null keymap)
        (which-key--hide-popup-ignore-command)
      (which-key--show-keymap
       (if (eq (plist-get (car targets) :type) 'embark-become)
           "Become"
         (format "Act on %s '%s'%s"
                 (plist-get (car targets) :type)
                 (embark--truncate-target (plist-get (car targets) :target))
                 (if (cdr targets) "…" "")))
       (if prefix
           (pcase (lookup-key keymap prefix 'accept-default)
             ((and (pred keymapp) km) km)
             (_ (key-binding prefix 'accept-default)))
         keymap)
       nil nil t (lambda (binding)
                   (not (string-suffix-p "-argument" (cdr binding))))))))

(setq embark-indicators
  '(embark-which-key-indicator
    embark-highlight-indicator
    embark-isearch-highlight-indicator))

(defun embark-hide-which-key-indicator (fn &rest args)
  "Hide the which-key indicator immediately when using the completing-read prompter."
  (which-key--hide-popup-ignore-command)
  (let ((embark-indicators
         (remq #'embark-which-key-indicator embark-indicators)))
      (apply fn args)))

(advice-add #'embark-completing-read-prompter
            :around #'embark-hide-which-key-indicator)
#+end_src

* Org

Config:
#+begin_src emacs-lisp
;; Stright builds org from upstream and it has a version mismatch with other org packages. This instructs straight to use the org version shiped with emacs.
(use-package org :straight (:type built-in))

(setq org-edit-src-content-indentation 0
      org-startup-indented t
      org-ellipsis "  ")

;; This only works if the cursor is in the 'xxx:' part of the link
(defun +org-return ()
  (interactive)
  (if (string= (car (org-element-context)) "link")
      (org-open-at-point)
    (evil-ret)))

(with-eval-after-load 'evil-collection
  (evil-define-key* 'normal org-mode-map (kbd "RET") '+org-return)) ;; Make RET open links
#+end_src

** Fonts

#+begin_src emacs-lisp
(let* ((variable-tuple
         (cond ((x-list-fonts "DejaVuSansMono Nerd Font Mono")  '(:font "DejaVuSansMono Nerd Font Mono"))
               ((x-list-fonts "ETBembo")         '(:font "ETBembo"))
               ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
               ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
               ((x-list-fonts "Verdana")         '(:font "Verdana"))
               ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
               (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro.")))))

      (custom-set-faces
       `(org-level-8        ((t (,@variable-tuple))))
       `(org-level-7        ((t (,@variable-tuple))))
       `(org-level-6        ((t (,@variable-tuple))))
       `(org-level-5        ((t (,@variable-tuple))))
       `(org-level-4        ((t (,@variable-tuple :height 1.0  :weight bold))))
       `(org-level-3        ((t (,@variable-tuple :height 1.05  :weight bold))))
       `(org-level-2        ((t (,@variable-tuple :height 1.1 :weight bold))))
       `(org-level-1        ((t (,@variable-tuple :height 1.15  :weight bold))))
       `(org-document-title ((t (,@variable-tuple :height 1.3 :weight bold :foreground "sky blue"))))))
#+end_src

** Markers

#+begin_src emacs-lisp
(use-package org-appear
  :hook
  (org-mode . org-appear-mode)
  :config
  (setq org-appear-trigger 'manual
        org-hide-emphasis-markers t
        org-appear-autolinks t
        org-pretty-entities t
        org-appear-autoentities t
        org-appear-autosubmarkers t)
  :init
  (add-hook 'org-mode-hook (lambda ()
                             (add-hook 'evil-insert-state-entry-hook
                                       #'org-appear-manual-start
                                       nil
                                       t)
                             (add-hook 'evil-insert-state-exit-hook
                                       #'org-appear-manual-stop
                                       nil
                                       t))))
#+end_src

** Superstar

#+begin_src emacs-lisp
(use-package org-superstar
  :hook (org-mode . org-superstar-mode))
#+end_src

** PDF

Open org links to PDF in pdf-tools.
#+begin_src emacs-lisp
(use-package org-pdftools
  :hook (org-mode . org-pdftools-setup-link))
#+end_src

** Sticky header

#+begin_src emacs-lisp
(use-package org-sticky-header
  :hook
  (org-mode . org-sticky-header-mode)
  :config
  (setq org-sticky-header-show-keyword nil
        org-sticky-header-heading-star ""
        org-sticky-header-full-path 'reversed))
#+end_src

* Shells
** Vterm

*Settings:*
#+begin_src emacs-lisp
(add-hook 'vterm-mode-hook #'hide-mode-line-mode) 
#+end_src

*** Toggle

#+begin_src emacs-lisp
(use-package vterm-toggle
  :bind
  ("C-x t v" . vterm-toggle))
#+end_src

** Shell

*Settings:*
#+begin_src emacs-lisp
(add-hook 'shell-mode-hook #'hide-mode-line-mode) 
#+end_src

*** Toggle

#+begin_src emacs-lisp
(use-package shell-pop
  :bind
  ("C-x t s" . shell-pop))
#+end_src

** Eshell

*Settings:*
#+begin_src emacs-lisp
;; Avoid cursor going before prompt
(add-hook 'eshell-mode-hook #'(lambda () ;; Eshell overrides the map after initialization therefore we have to set it after.
                                (local-set-key (kbd "<home>") #'eshell-bol)))

(setq eshell-scroll-to-bottom-on-input 'all
      eshell-scroll-to-bottom-on-output 'all
      eshell-kill-processes-on-exit t
      eshell-hist-ignoredups t
      ;; don't record command in history if prefixed with whitespace
      ;; TODO Use `eshell-input-filter-initial-space' when Emacs 25 support is dropped
      eshell-input-filter (lambda (input) (not (string-match-p "\\`\\s-+" input)))
      ;; em-glob
      eshell-glob-case-insensitive t
      eshell-error-if-no-glob t)

;; Remove modeline
(add-hook 'eshell-mode-hook #'hide-mode-line-mode)
#+end_src

*** Toggle

#+begin_src emacs-lisp
(use-package eshell-toggle
  :bind
  ("C-x t e" . eshell-toggle))
#+end_src

*** Clear

#+begin_src emacs-lisp
(add-hook 'eshell-mode-hook (lambda ()
                              (defun eshell/clear ()
                                "Clear the eshell buffer."
                                (let ((inhibit-read-only t))
                                  (erase-buffer)
                                  (eshell/clear-scrollback)))))

(defun run-this-in-eshell (cmd)
  "Runs the command 'cmd' in eshell."
  (with-current-buffer "*eshell*"
    (end-of-buffer)
    (eshell-kill-input)
    (message (concat "Running in Eshell: " cmd))
    (insert cmd)
    (eshell-send-input)
    (end-of-buffer)
    (eshell-bol)
    (yank)))

(add-hook 'eshell-mode-hook #'(lambda ()
                                (local-set-key (kbd "C-l") #'(lambda ()
                                                               (interactive)
                                                               (run-this-in-eshell "clear")))))
#+end_src

*** Aliases

#+begin_src emacs-lisp
(defun eshell/ff (&rest args)
  (apply #'find-file args))

(defun eshell/fo (&rest args)
  (apply #'find-file-other-window args))
#+end_src

*** Suggestions

#+begin_src emacs-lisp
(use-package esh-autosuggest
  :hook (eshell-mode . esh-autosuggest-mode)) 
#+end_src

*** Fancy prompt

Needed packages:
#+begin_src emacs-lisp :tangle no
(use-package eshell-prompt-extras
  :config
  ;; Display python virtual environment
  (with-eval-after-load "esh-opt"
  (unless (and (fboundp 'package-installed-p)
               (package-installed-p 'virtualenvwrapper)) ;; This requires virtualenvwrapper to work
    (package-install 'virtualenvwrapper))
  (venv-initialize-eshell)
  ;; Add lambda theme
  (autoload 'epe-theme-lambda "eshell-prompt-extras")
  (setq eshell-highlight-prompt nil
        eshell-prompt-function #'epe-theme-lambda)))
#+end_src

Custom banner:
#+begin_src emacs-lisp
(eval-after-load "eshell"
  (setq eshell-banner-message
        '(format "%s %s\n"
                 (propertize (format " %s " (string-trim (buffer-name)))
                             'face 'mode-line-highlight)
                 (propertize (current-time-string)
                             'face 'font-lock-keyword-face))))  
#+end_src

**** Doom prompt

#+begin_src emacs-lisp :tangle no
(defun doom-call-process (command &rest args)
  "Execute COMMAND with ARGS synchronously.
Returns (STATUS . OUTPUT) when it is done, where STATUS is the returned error
code of the process and OUTPUT is its stdout output."
  (with-temp-buffer
    (cons (or (apply #'call-process command nil t nil (remq nil args))
              -1)
          (string-trim (buffer-string)))))

(defface +eshell-prompt-pwd '((t (:inherit font-lock-constant-face)))
  "TODO"
  :group 'eshell)

(defface +eshell-prompt-git-branch '((t (:inherit font-lock-regexp-grouping-construct)))
  "TODO"
  :group 'eshell)

(defun +eshell--current-git-branch ()
  ;; TODO Refactor me
  (cl-destructuring-bind (status . output)
      (doom-call-process "git" "symbolic-ref" "-q" "--short" "HEAD")
    (if (equal status 0)
        (format " [%s]" output)
      (cl-destructuring-bind (status . output)
          (doom-call-process "git" "describe" "--all" "--always" "HEAD")
        (if (equal status 0)
            (format " [%s]" output)
          "")))))

(defun +eshell-default-prompt-fn ()
  "Generate the prompt string for eshell. Use for `eshell-prompt-function'."
  (require 'shrink-path)
  (concat (if (bobp) "" "\n")
          (let ((pwd (eshell/pwd)))
            (propertize (if (equal pwd "~")
                            pwd
                          (abbreviate-file-name (shrink-path-file pwd)))
                        'face '+eshell-prompt-pwd))
          (propertize (+eshell--current-git-branch)
                      'face '+eshell-prompt-git-branch)
          (propertize " λ" 'face (if (zerop eshell-last-command-status) 'success 'error))
          " "))

(eval-after-load "eshell"
  ;; em-prompt
  (setq eshell-prompt-regexp "^.* λ "
        eshell-prompt-function #'+eshell-default-prompt-fn))
#+end_src

**** Many Icons prompt

Prompt from: [[http://www.modernemacs.com/post/custom-eshell/][Modern Emacs - Making eshell your own]]
#+begin_src emacs-lisp
(require 'dash)
(require 's)

(defmacro with-face (STR &rest PROPS)
  "Return STR propertized with PROPS."
  `(propertize ,STR 'face (list ,@PROPS)))

(defmacro esh-section (NAME ICON FORM &rest PROPS)
  "Build eshell section NAME with ICON prepended to evaled FORM with PROPS."
  `(setq ,NAME
         (lambda () (when ,FORM
                 (-> ,ICON
                    (concat esh-section-delim ,FORM)
                    (with-face ,@PROPS))))))

(defun esh-acc (acc x)
  "Accumulator for evaluating and concatenating esh-sections."
  (--if-let (funcall x)
      (if (s-blank? acc)
          it
        (concat acc esh-sep it))
    acc))

(defun esh-prompt-func ()
  "Build `eshell-prompt-function'"
  (concat esh-header
          (-reduce-from 'esh-acc "" eshell-funcs)
          "\n"
          eshell-prompt-string))

(defun check-empty-dir ()
  (if (directory-empty-p (eshell/pwd))
    (char-to-string ?)
  (char-to-string ?)))

(esh-section esh-dir
             (check-empty-dir)  ;  (get icon folder)
             (abbreviate-file-name (eshell/pwd))
             '(:inherit outline-3 :bold ultra-bold :underline t))

(esh-section esh-git
             ""  ;  (git icon)
             (magit-get-current-branch)
             '(:inherit outline-4))

(esh-section esh-python
             ""  ;  (python icon)
             (boundp 'pyvenv-virtual-env-name))

(esh-section esh-clock
             ""  ;  (clock icon)
             (format-time-string "%H:%M" (current-time))
             '(:inherit outline-7))

;; Below I implement a "prompt number" section
(setq esh-prompt-num 0)
(add-hook 'eshell-exit-hook (lambda () (setq esh-prompt-num 0)))
(advice-add 'eshell-send-input :before
            (lambda (&rest args) (setq esh-prompt-num (cl-incf esh-prompt-num))))

(esh-section esh-num
             "\xf0c9"  ;  (list icon)
             (number-to-string esh-prompt-num)
             '(:inherit outline-1))

;; Separator between esh-sections
(setq esh-sep "  ")  ; or " | "

;; Separator between an esh-section icon and form
(setq esh-section-delim " ")

;; Eshell prompt header
(setq esh-header "\n╭─ ")  ; or "\n┌─"

;; Eshell prompt regexp and string. Unless you are varying the prompt by eg.
;; your login, these can be the same.
(setq eshell-prompt-regexp "╰─ ")   ; or "└─> "
(setq eshell-prompt-string "╰─ ")   ; or "└─> "

;; Choose which eshell-funcs to enable
(setq eshell-funcs (list esh-dir esh-git esh-python esh-clock esh-num))

;; Enable the new eshell prompt
(setq eshell-prompt-function 'esh-prompt-func)
#+end_src

* Dired

Load the extra dired libraries.
#+begin_src emacs-lisp
(require 'dired-x)
(require 'dired-aux)
#+end_src

Display options for dired. They are the same as the ls command:
#+begin_quote
=-A, --almost-all=
      do not list implied . and ..

=-l=    use a long listing format

=-h, --human-readable=
      with -l and -s, print sizes like 1K 234M 2G etc.

=-t=    sort by time, newest first; see --time

=--group-directories-first=
      roup directories before files;
#+end_quote

#+begin_src emacs-lisp
(setq dired-listing-switches "-Alht --group-directories-first")
#+end_src

** Subtree

This package defines function dired-subtree-insert which instead inserts the subdirectory directly below its line in the original listing, and indent the listing of subdirectory to resemble a tree-like structure (somewhat similar to tree(1) except the pretty graphics). The tree display is somewhat more intuitive than the default "flat" subdirectory manipulation provided by i.
#+begin_src emacs-lisp
(use-package dired-subtree
  :bind (:map dired-mode-map
              ("<tab>" . dired-subtree-toggle)))
#+end_src

** Filtering

#+begin_src emacs-lisp
(use-package dired-filter
  :bind
  (:map dired-mode-map
        ("C-c g" . dired-filter-group-mode))
  (:map dired-filter-group-mode-map
        ("<tab>" . nil) ;; Free unused keybinding
        ("C-<tab>" . dired-filter-group-forward-drawer)
        ("M-<tab>" . dired-filter-group-backward-drawer))
  :hook
  (dired-mode . dired-filter-group-mode)
  :custom
  (dired-filter-group-saved-groups
   '(("default"
      ("directory"
       (extension . "d.*"))
      ("html"
       (extension . ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml")))
      ("xml"
       (extension . ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata")))
      ("document"
       (extension . ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx")))
      ("markdown"
       (extension . ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt")))
      ("database"
       (extension . ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc")))
      ("media"
       (extension . ("mp3" "mp4" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac")))
      ("image"
       (extension . ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg")))
      ("log"
       (extension . ("log")))
      ("shell"
       (extension . ("awk" "bash" "bat" "sed" "sh" "zsh" "vim")))
      ("interpreted"
       (extension . ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js")))
      ("compiled"
       (extension . ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java")))
      ("executable"
       (extension . ("exe" "msi")))
      ("compressed"
       (extension . ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar")))
      ("packaged"
       (extension . ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp")))
      ("encrypted"
       (extension . ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem")))
      ("fonts"
       (extension . ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf")))
      ("partition"
       (extension . ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak")))
      ("vc"
       (extension . ("git" "gitignore" "gitattributes" "gitmodules")))
      ("executable-unix"
       (extension . "-.*x.*"))))))
#+end_src

** Collapse

Often times we find ourselves in a situation where a single file or directory is nested in a chain of nested directories with no other content. This is sometimes due to various mandatory layouts demanded by packaging tools or tools generating these deeply-nested "unique" paths to disambiguate architectures or versions (but we often use only one anyway). If the user wants to access these directories they have to quite needlessly drill-down through varying number of "uninteresting" directories to get to the content.
#+begin_src emacs-lisp
(use-package dired-collapse
  :hook
  (dired-mode . dired-collapse-mode))
#+end_src

** External open

This package adds a mechanism to add "hooks" to dired-find-file that will run before emacs tries its own mechanisms to open the file, thus enabling you to launch other application or code and suspend the default behaviour.
#+begin_src emacs-lisp
(use-package dired-open
  :bind (:map dired-mode-map
              ("C-<return>" . dired-open-xdg)
              ("C-c o" . dired-open-xdg)))
#+end_src

** Ranger

This package implements useful features present in the ranger file manager which are missing in dired. This includes multi-stage copying with ~dired-ranger-copy~
#+begin_src emacs-lisp
(use-package dired-ranger
  :bind (:map dired-mode-map
              ("C-c y" . dired-ranger-copy)
              ("C-c p" . dired-ranger-paste)
              ("C-c m" . dired-ranger-move)))
#+end_src

** Rsync

This repository provides a transient version called dired-transient-rsync. This wraps the command in a `magit` like transient interface allowing you to tweaks the parameters for your call.
#+begin_src emacs-lisp
(use-package dired-rsync
  :bind (:map dired-mode-map
              ("C-c r" . dired-rsync-transient)))
#+end_src


** Theming

*** Icons

Add icons.
#+begin_src emacs-lisp
(use-package all-the-icons-dired
  :hook
  (dired-mode . all-the-icons-dired-mode)
  :init (setq all-the-icons-dired-monochrome nil))
#+end_src

*** Extra font locks

Extra font lock rules for a more colourful dired (eg. font lock on permissions).
#+begin_src emacs-lisp
(use-package diredfl
  :init
  (diredfl-global-mode))
#+end_src

* PDF

#+begin_src emacs-lisp
(use-package pdf-tools
  :config
  (pdf-tools-install)
  :bind (:map pdf-view-mode-map
              ("\\" . hydra-pdftools/body)
              ("<s-spc>" .  pdf-view-scroll-down-or-next-page)
              ("g"  . pdf-view-first-page)
              ("G"  . pdf-view-last-page)
              ("l"  . image-forward-hscroll)
              ("h"  . image-backward-hscroll)
              ("j"  . pdf-view-next-page)
              ("k"  . pdf-view-previous-page)
              ("e"  . pdf-view-goto-page)
              ("u"  . pdf-view-revert-buffer)
              ("al" . pdf-annot-list-annotations)
              ("ad" . pdf-annot-delete)
              ("aa" . pdf-annot-attachment-dired)
              ("am" . pdf-annot-add-markup-annotation)
              ("at" . pdf-annot-add-text-annotation)
              ("y"  . pdf-view-kill-ring-save)
              ("i"  . pdf-misc-display-metadata)
              ("s"  . pdf-occur)
              ("b"  . pdf-view-set-slice-from-bounding-box)
              ("r"  . pdf-view-reset-slice)))

;; Hydra menu
(defhydra hydra-pdftools (:color blue :hint nil)
        "
                                                                      ╭───────────┐
       Move  History   Scale/Fit     Annotations  Search/Link    Do   │ PDF Tools │
   ╭──────────────────────────────────────────────────────────────────┴───────────╯
         ^^_g_^^      _B_    ^↧^    _+_    ^ ^     [_al_] list    [_s_] search    [_u_] revert buffer
         ^^^↑^^^      ^↑^    _H_    ^↑^  ↦ _W_ ↤   [_am_] markup  [_o_] outline   [_i_] info
         ^^_p_^^      ^ ^    ^↥^    _0_    ^ ^     [_at_] text    [_F_] link      [_d_] dark mode
         ^^^↑^^^      ^↓^  ╭─^─^─┐  ^↓^  ╭─^ ^─┐   [_ad_] delete  [_f_] search link
    _h_ ←pag_e_→ _l_  _N_  │ _P_ │  _-_    _b_     [_aa_] dired
         ^^^↓^^^      ^ ^  ╰─^─^─╯  ^ ^  ╰─^ ^─╯   [_y_]  yank
         ^^_n_^^      ^ ^  _r_eset slice box
         ^^^↓^^^
         ^^_G_^^
   --------------------------------------------------------------------------------
        "
        ("\\" hydra-master/body "back")
        ("<ESC>" nil "quit")
        ("al" pdf-annot-list-annotations)
        ("ad" pdf-annot-delete)
        ("aa" pdf-annot-attachment-dired)
        ("am" pdf-annot-add-markup-annotation)
        ("at" pdf-annot-add-text-annotation)
        ("y"  pdf-view-kill-ring-save)
        ("+" pdf-view-enlarge :color red)
        ("-" pdf-view-shrink :color red)
        ("0" pdf-view-scale-reset)
        ("H" pdf-view-fit-height-to-window)
        ("W" pdf-view-fit-width-to-window)
        ("P" pdf-view-fit-page-to-window)
        ("n" pdf-view-next-page-command :color red)
        ("p" pdf-view-previous-page-command :color red)
        ("d" pdf-view-dark-minor-mode)
        ("b" pdf-view-set-slice-from-bounding-box)
        ("r" pdf-view-reset-slice)
        ("g" pdf-view-first-page)
        ("G" pdf-view-last-page)
        ("e" pdf-view-goto-page)
        ("o" pdf-outline)
        ("s" pdf-occur)
        ("i" pdf-misc-display-metadata)
        ("u" pdf-view-revert-buffer)
        ("F" pdf-links-action-perfom)
        ("f" pdf-links-isearch-link)
        ("B" pdf-history-backward :color red)
        ("N" pdf-history-forward :color red)
        ("l" image-forward-hscroll :color red)
        ("h" image-backward-hscroll :color red))
#+end_src

* DIFF

By default ediff spawns a new frame to display files to be compared or merged. Remove that. Also save window layout before ediff and restore on exit.
#+begin_src emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain
      ediff-split-window-function 'split-window-horizontally)

;; Some custom configuration to ediff
(defvar my-ediff-bwin-config nil "Window configuration before ediff.")
(defcustom my-ediff-bwin-reg ?b
  "*Register to be set up to hold `my-ediff-bwin-config'
    configuration.")

(defvar my-ediff-awin-config nil "Window configuration after ediff.")
(defcustom my-ediff-awin-reg ?e
  "*Register to be used to hold `my-ediff-awin-config' window
    configuration.")

(defun my-ediff-bsh ()
  "Function to be called before any buffers or window setup for
    ediff."
  (setq my-ediff-bwin-config (current-window-configuration))
  (when (characterp my-ediff-bwin-reg)
    (set-register my-ediff-bwin-reg
    		  (list my-ediff-bwin-config (point-marker)))))

(defun my-ediff-ash ()
  "Function to be called after buffers and window setup for ediff."
  (setq my-ediff-awin-config (current-window-configuration))
  (when (characterp my-ediff-awin-reg)
    (set-register my-ediff-awin-reg
    		  (list my-ediff-awin-config (point-marker)))))

(defun my-ediff-qh ()
  "Function to be called when ediff quits."
  (when my-ediff-bwin-config
    (set-window-configuration my-ediff-bwin-config)))

(add-hook 'ediff-before-setup-hook 'my-ediff-bsh)
(add-hook 'ediff-after-setup-windows-hook 'my-ediff-ash 'append)
(add-hook 'ediff-quit-hook 'my-ediff-qh)
#+end_src

* Syntax highlighting
** Color identifiers
Color Identifiers is a minor mode for Emacs that highlights each source code identifier uniquely based on its name. It
#+begin_src emacs-lisp
(use-package color-identifiers-mode
  :hook
  (after-init . global-color-identifiers-mode))

;; Not used for now
;; (add-hook 'lsp-ccls-after-open-hook 'color-identifiers:regenerate-colors)
;; (add-hook 'lsp-pyright-after-open-hook 'color-identifiers:regenerate-colors)
#+end_src

** Rainbow mode
Highlight hex digits
#+begin_src emacs-lisp
(use-package rainbow-mode)

;; Rainbow mode colors cannot be displayed properly over hl-line-mode. Disable when toggling rainbow-mode.
(add-hook 'rainbow-mode-hook (lambda ()
                               (if (bound-and-true-p rainbow-mode)
                                   (hl-line-mode -1)
                                 (hl-line-mode 1))))
#+end_src

** Prism
Prism disperses lisp forms (and other languages) into a spectrum of color by depth. It’s similar to rainbow-blocks, but it respects existing non-color face properties, and allows flexible configuration of faces and colors. It also optionally colorizes strings and/or comments by code depth in a similar, customizable way.
#+begin_src emacs-lisp
(use-package prism)
#+end_src

If the colors are not pleasant use =prism-randomize-colors=.

* Projectile

Add project management to emacs.
#+begin_src emacs-lisp
(use-package projectile
  :bind (("C-c p" . projectile-command-map))
  :init
  (projectile-mode))
#+end_src

* Extras
** Nicieties

#+begin_src emacs-lisp
;; Emacs 28: Hide commands in M-x which do not work in the current mode.
;; Vertico commands are hidden in normal buffers.
(setq read-extended-command-predicate #'command-completion-default-include-p
      enable-recursive-minibuffers t)

(defun +reload-emacs ()
    "Reload the Emacs configuration"
    (interactive)
    (load-file "~/.emacs.d/init.el"))

;; Supress warnings but enable them on debug
(if init-file-debug
      (setq warning-minimum-level :debug)
    (setq warning-minimum-level :emergency))
#+end_src

*** Autorevert

#+begin_src emacs-lisp
(setq auto-revert-interval 0.5
      global-auto-revert-non-file-buffers t ;; Revert buffers like Dired
      auto-revert-verbose nil) ;; Don't ask when reverting

(define-key override-global-map (kbd "C-x r b") #'revert-buffer)

;; Auto revert files when they change
(global-auto-revert-mode t)
#+end_src

** Handle very long lines

When the lines in a file are so long that performance could suffer to an
unacceptable degree, we say "so long" to the slow modes and options enabled
in that buffer, and invoke something much more basic in their place.
#+begin_src emacs-lisp
(use-package so-long
  :hook (after-init-hook . global-so-long-mode))
#+end_src

** Scrolling

#+begin_src emacs-lisp
(use-package good-scroll
  :config
  (setq scroll-step 1)
  :bind
  ("<next>" . good-scroll-up-full-screen)
  ("<prior>" . good-scroll-down-full-screen)
  :init
  (good-scroll-mode 1))
#+end_src

** Screenshot

#+begin_src emacs-lisp
(use-package screenshot
  :straight (screenshot :type git :host github :repo "tecosaur/screenshot"))
#+end_src

* Programming
** Formaters
*** Clang-format

#+begin_src emacs-lisp
(use-package clang-format+
  :hook (c-mode-common . clang-format+-mode))
#+end_src

This offers formating of the buffer but the emacs editing style remains unchanges so hitting TAB might not align with what .Clang-format specifies. Here is a function to set the emacs formating style according to the .clang-format
#+begin_src emacs-lisp
(require 's) ;; Needed for s-match, load it first

(defun get-clang-format-option (config-str field is-num)
  "Retrieve a config option from a clang-format config.

CONFIG-STR is a string containing the entire clang-format config.
FIELD is specific option, e.g. `IndentWidth'.  IS-NUM is a
boolean that should be set to 1 if the option is numeric,
otherwise assumed alphabetic."
  (if is-num
      (let ((primary-match (s-match (concat "^" field ":[ \t]*[0-9]+") config-str)))
        (if primary-match
            (string-to-number (car (s-match "[0-9]+" (car primary-match))))
          0))
    (let ((primary-match (s-match (concat "^" field ":[ \t]*[A-Za-z]+") config-str)))
      (if primary-match
          (car (s-match "[A-Za-z]+$" (car primary-match)))
        ""))))

(add-hook 'c-mode-common-hook  #'(lambda ()
                              (let* ((clang-format-config
                                      (shell-command-to-string "clang-format -dump-config"))
                                     (c-offset (get-clang-format-option clang-format-config "IndentWidth" t))
                                     (tabs-str (get-clang-format-option clang-format-config "UseTab" nil))
                                     (base-style
                                      (get-clang-format-option clang-format-config "BasedOnStyle" nil)))
                                (progn
                                  (if (> c-offset 0)
                                      (setq-local c-basic-offset c-offset)
                                    (if (not (equal "" base-style))
                                        (cond ((or (equal "LLVM" base-style)
                                                   (equal "Google" base-style)
                                                   (equal "Chromium" base-style)
                                                   (equal "Mozilla" base-style))
                                               (setq-local c-basic-offset 2))
                                              ((equal "WebKit" base-style)
                                               (setq-local c-basic-offset 4)))))
                                  (if (not (equal "" tabs-str))
                                      (if (not (string-equal "Never" tabs-str))
                                          (setq-local indent-tabs-mode t)
                                        (setq-local indent-tabs-mode nil))
                                    (if (not (equal "" base-style))
                                        (cond ((or (equal "LLVM" base-style)
                                                   (equal "Google" base-style)
                                                   (equal "Chromium" base-style)
                                                   (equal "Mozilla" base-style)
                                                   (equal "WebKit" base-style))
                                               (setq-local indent-tabs-mode nil)))))))))
#+end_src

** Syntax checkers
*** Flycheck

Use the more modern syntax checker (Flycheck) over the built-in Flymake. LSP mode will automatically pick it up.
#+begin_src emacs-lisp
(use-package flycheck)
#+end_src

** Language server providers
*** Eglot

Lightweight LSP client.
#+begin_src emacs-lisp
(use-package eglot)
#+end_src

*** TODO LSP

Full fledged LSP client.
#+begin_src emacs-lisp
(use-package lsp-mode
  :hook
  (lsp-mode . lsp-enable-which-key-integration)
  :custom
  (lsp-keymap-prefix "C-c l")
  (lsp-completion-provider :none) ;; Remove the providers so Corfu can take precedence.
  :init
  (lsp-dired-mode))
#+end_src

**** UI

Fancy sideline, popup documentation, VScode-like peek UI, etc.
#+begin_src emacs-lisp
(use-package lsp-ui
  :after lsp-mode
  :bind (:map lsp-ui-mode-map
              ([remap xref-find-definitions] . lsp-ui-peek-find-definitions)
              ([remap xref-find-references] . lsp-ui-peek-find-references)))
#+end_src

**** Treemacs

Integration between lsp-mode and treemacs and implementation of treeview controls using treemacs as a tree renderer.
#+begin_src emacs-lisp
(use-package lsp-treemacs
  :after lsp-mode
  :init
  (lsp-treemacs-sync-mode))
#+end_src

**** Consult

Mimic a few features of helm-lsp and lsp-ivy in consult workflow.
#+begin_src emacs-lisp
(use-package consult-lsp
  :after lsp-mode
  :bind (:map lsp-mode-map
              ([remap xref-find-apropos] . consult-lsp-symbols)))
#+end_src

** Debuggers

*** TODO DAP

#+begin_src emacs-lisp
(use-package dap-mode
  :init
  (dap-auto-configure-mode))
#+end_src

** Python

Load the python debugger library.
#+begin_src emacs-lisp
(require 'dap-python)
#+end_src

** C
*** Language servers
**** CCLS

This is needed to provide support for CCLS to LSP-mode.
#+begin_src emacs-lisp
(use-package ccls)
#+end_src

** HTML
*** Htmlize

This package converts the buffer text and the associated decorations to HTML. It allows org export to colorize src blocks
#+begin_src emacs-lisp
(use-package htmlize)
#+end_src

* TODO [2/7] [28%]
+ [ ] Winner undoo
+ [ ] Change focus
+ [ ] Popper
+ [ ] Shackles
+ [ ] Ediff opens control window in a new frame
+ [ ] Evil-collection should provide bindings for diff-hl
+ [X] Eshell is slow on the first command (some icons are slow to load)
+ [X] Org-ret open at point now it wont oppen unless is litteraly inside of the link part not on the description
